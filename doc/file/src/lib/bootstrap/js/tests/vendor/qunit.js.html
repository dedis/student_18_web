<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../../../../">
  <title data-ice="title">src/lib/bootstrap/js/tests/vendor/qunit.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/app.js~App.html">App</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">components/html-iframe</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/components/html-iframe/html-iframe.js~HTMLIFrame.html">HTMLIFrame</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">components/loading</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/components/loading/loading-spinner.js~LoadingSpinner.html">LoadingSpinner</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">components/module/html</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/components/module/html/module-html.js~ModuleHTML.html">ModuleHTML</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">components/module/random</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/components/module/random/module-random.js~ModuleRandom.html">ModuleRandom</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">components/module/signature</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/components/module/signature/module-sign.js~BlockSign.html">BlockSign</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/components/module/signature/module-verify.js~VerifyModule.html">VerifyModule</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">components/module/skipchain</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/components/module/skipchain/module-skipchain.js~ModuleSkipChain.html">ModuleSkipChain</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">components/servers-status</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/components/servers-status/servers-status.js~ServersStatus.html">ServersStatus</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">lib</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/lib/cothority-messages.js~CothorityMessages.html">CothorityMessages</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/lib/cothority-messages.js~CothorityProtobuf.html">CothorityProtobuf</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-index">index</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">lib/bootstrap/js/src</div><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Alert">Alert</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Button">Button</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Carousel">Carousel</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Collapse">Collapse</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Dropdown">Dropdown</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Modal">Modal</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Popover">Popover</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ScrollSpy">ScrollSpy</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Tab">Tab</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Tooltip">Tooltip</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Util">Util</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">services</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/services/iframe.js~IFrameService.html">IFrameService</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/services/skipchain.js~SkipChainService.html">SkipChainService</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">utils</div><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-buf2hex">buf2hex</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-hex2buf">hex2buf</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-hashFile">hashFile</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-readAsString">readAsString</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-tcp2ws">tcp2ws</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/lib/bootstrap/js/tests/vendor/qunit.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/*!
 * QUnit 2.0.1
 * https://qunitjs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2016-07-23T19:39Z
 */

( function( global ) {

var QUnit = {};

var Date = global.Date;
var now = Date.now || function() {
	return new Date().getTime();
};

var setTimeout = global.setTimeout;
var clearTimeout = global.clearTimeout;

// Store a local window from the global to allow direct references.
var window = global.window;

var defined = {
	document: window &amp;&amp; window.document !== undefined,
	setTimeout: setTimeout !== undefined,
	sessionStorage: ( function() {
		var x = &quot;qunit-test-string&quot;;
		try {
			sessionStorage.setItem( x, x );
			sessionStorage.removeItem( x );
			return true;
		} catch ( e ) {
			return false;
		}
	}() )
};

var fileName = ( sourceFromStacktrace( 0 ) || &quot;&quot; ).replace( /(:\d+)+\)?/, &quot;&quot; ).replace( /.+\//, &quot;&quot; );
var globalStartCalled = false;
var runStarted = false;

var autorun = false;

var toString = Object.prototype.toString,
	hasOwn = Object.prototype.hasOwnProperty;

// Returns a new Array with the elements that are in a but not in b
function diff( a, b ) {
	var i, j,
		result = a.slice();

	for ( i = 0; i &lt; result.length; i++ ) {
		for ( j = 0; j &lt; b.length; j++ ) {
			if ( result[ i ] === b[ j ] ) {
				result.splice( i, 1 );
				i--;
				break;
			}
		}
	}
	return result;
}

// From jquery.js
function inArray( elem, array ) {
	if ( array.indexOf ) {
		return array.indexOf( elem );
	}

	for ( var i = 0, length = array.length; i &lt; length; i++ ) {
		if ( array[ i ] === elem ) {
			return i;
		}
	}

	return -1;
}

/**
 * Makes a clone of an object using only Array or Object as base,
 * and copies over the own enumerable properties.
 *
 * @param {Object} obj
 * @return {Object} New object with only the own properties (recursively).
 */
function objectValues ( obj ) {
	var key, val,
		vals = QUnit.is( &quot;array&quot;, obj ) ? [] : {};
	for ( key in obj ) {
		if ( hasOwn.call( obj, key ) ) {
			val = obj[ key ];
			vals[ key ] = val === Object( val ) ? objectValues( val ) : val;
		}
	}
	return vals;
}

function extend( a, b, undefOnly ) {
	for ( var prop in b ) {
		if ( hasOwn.call( b, prop ) ) {
			if ( b[ prop ] === undefined ) {
				delete a[ prop ];
			} else if ( !( undefOnly &amp;&amp; typeof a[ prop ] !== &quot;undefined&quot; ) ) {
				a[ prop ] = b[ prop ];
			}
		}
	}

	return a;
}

function objectType( obj ) {
	if ( typeof obj === &quot;undefined&quot; ) {
		return &quot;undefined&quot;;
	}

	// Consider: typeof null === object
	if ( obj === null ) {
		return &quot;null&quot;;
	}

	var match = toString.call( obj ).match( /^\[object\s(.*)\]$/ ),
		type = match &amp;&amp; match[ 1 ];

	switch ( type ) {
		case &quot;Number&quot;:
			if ( isNaN( obj ) ) {
				return &quot;nan&quot;;
			}
			return &quot;number&quot;;
		case &quot;String&quot;:
		case &quot;Boolean&quot;:
		case &quot;Array&quot;:
		case &quot;Set&quot;:
		case &quot;Map&quot;:
		case &quot;Date&quot;:
		case &quot;RegExp&quot;:
		case &quot;Function&quot;:
		case &quot;Symbol&quot;:
			return type.toLowerCase();
	}
	if ( typeof obj === &quot;object&quot; ) {
		return &quot;object&quot;;
	}
}

// Safe object type checking
function is( type, obj ) {
	return QUnit.objectType( obj ) === type;
}

// Doesn&apos;t support IE9, it will return undefined on these browsers
// See also https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error/Stack
function extractStacktrace( e, offset ) {
	offset = offset === undefined ? 4 : offset;

	var stack, include, i;

	if ( e.stack ) {
		stack = e.stack.split( &quot;\n&quot; );
		if ( /^error$/i.test( stack[ 0 ] ) ) {
			stack.shift();
		}
		if ( fileName ) {
			include = [];
			for ( i = offset; i &lt; stack.length; i++ ) {
				if ( stack[ i ].indexOf( fileName ) !== -1 ) {
					break;
				}
				include.push( stack[ i ] );
			}
			if ( include.length ) {
				return include.join( &quot;\n&quot; );
			}
		}
		return stack[ offset ];
	}
}

function sourceFromStacktrace( offset ) {
	var error = new Error();

	// Support: Safari &lt;=7 only, IE &lt;=10 - 11 only
	// Not all browsers generate the `stack` property for `new Error()`, see also #636
	if ( !error.stack ) {
		try {
			throw error;
		} catch ( err ) {
			error = err;
		}
	}

	return extractStacktrace( error, offset );
}

/**
 * Config object: Maintain internal state
 * Later exposed as QUnit.config
 * `config` initialized at top of scope
 */
var config = {

	// The queue of tests to run
	queue: [],

	// Block until document ready
	blocking: true,

	// By default, run previously failed tests first
	// very useful in combination with &quot;Hide passed tests&quot; checked
	reorder: true,

	// By default, modify document.title when suite is done
	altertitle: true,

	// HTML Reporter: collapse every test except the first failing test
	// If false, all failing tests will be expanded
	collapse: true,

	// By default, scroll to top of the page when suite is done
	scrolltop: true,

	// Depth up-to which object will be dumped
	maxDepth: 5,

	// When enabled, all tests must call expect()
	requireExpects: false,

	// Placeholder for user-configurable form-exposed URL parameters
	urlConfig: [],

	// Set of all modules.
	modules: [],

	// Stack of nested modules
	moduleStack: [],

	// The first unnamed module
	currentModule: {
		name: &quot;&quot;,
		tests: []
	},

	callbacks: {}
};

// Push a loose unnamed module to the modules collection
config.modules.push( config.currentModule );

// Register logging callbacks
function registerLoggingCallbacks( obj ) {
	var i, l, key,
		callbackNames = [ &quot;begin&quot;, &quot;done&quot;, &quot;log&quot;, &quot;testStart&quot;, &quot;testDone&quot;,
			&quot;moduleStart&quot;, &quot;moduleDone&quot; ];

	function registerLoggingCallback( key ) {
		var loggingCallback = function( callback ) {
			if ( objectType( callback ) !== &quot;function&quot; ) {
				throw new Error(
					&quot;QUnit logging methods require a callback function as their first parameters.&quot;
				);
			}

			config.callbacks[ key ].push( callback );
		};

		return loggingCallback;
	}

	for ( i = 0, l = callbackNames.length; i &lt; l; i++ ) {
		key = callbackNames[ i ];

		// Initialize key collection of logging callback
		if ( objectType( config.callbacks[ key ] ) === &quot;undefined&quot; ) {
			config.callbacks[ key ] = [];
		}

		obj[ key ] = registerLoggingCallback( key );
	}
}

function runLoggingCallbacks( key, args ) {
	var i, l, callbacks;

	callbacks = config.callbacks[ key ];
	for ( i = 0, l = callbacks.length; i &lt; l; i++ ) {
		callbacks[ i ]( args );
	}
}

( function() {
	if ( !defined.document ) {
		return;
	}

	// `onErrorFnPrev` initialized at top of scope
	// Preserve other handlers
	var onErrorFnPrev = window.onerror;

	// Cover uncaught exceptions
	// Returning true will suppress the default browser handler,
	// returning false will let it run.
	window.onerror = function( error, filePath, linerNr ) {
		var ret = false;
		if ( onErrorFnPrev ) {
			ret = onErrorFnPrev( error, filePath, linerNr );
		}

		// Treat return value as window.onerror itself does,
		// Only do our handling if not suppressed.
		if ( ret !== true ) {
			if ( QUnit.config.current ) {
				if ( QUnit.config.current.ignoreGlobalErrors ) {
					return true;
				}
				QUnit.pushFailure( error, filePath + &quot;:&quot; + linerNr );
			} else {
				QUnit.test( &quot;global failure&quot;, extend( function() {
					QUnit.pushFailure( error, filePath + &quot;:&quot; + linerNr );
				}, { validTest: true } ) );
			}
			return false;
		}

		return ret;
	};
}() );

// Figure out if we&apos;re running the tests from a server or not
QUnit.isLocal = !( defined.document &amp;&amp; window.location.protocol !== &quot;file:&quot; );

// Expose the current QUnit version
QUnit.version = &quot;2.0.1&quot;;

extend( QUnit, {

	// Call on start of module test to prepend name to all tests
	module: function( name, testEnvironment, executeNow ) {
		var module, moduleFns;
		var currentModule = config.currentModule;

		if ( arguments.length === 2 ) {
			if ( objectType( testEnvironment ) === &quot;function&quot; ) {
				executeNow = testEnvironment;
				testEnvironment = undefined;
			}
		}

		module = createModule();

		if ( testEnvironment &amp;&amp; ( testEnvironment.setup || testEnvironment.teardown ) ) {
			console.warn(
				&quot;Module&apos;s `setup` and `teardown` are not hooks anymore on QUnit 2.0, use &quot; +
				&quot;`beforeEach` and `afterEach` instead\n&quot; +
				&quot;Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/&quot;
			);
		}

		moduleFns = {
			before: setHook( module, &quot;before&quot; ),
			beforeEach: setHook( module, &quot;beforeEach&quot; ),
			afterEach: setHook( module, &quot;afterEach&quot; ),
			after: setHook( module, &quot;after&quot; )
		};

		if ( objectType( executeNow ) === &quot;function&quot; ) {
			config.moduleStack.push( module );
			setCurrentModule( module );
			executeNow.call( module.testEnvironment, moduleFns );
			config.moduleStack.pop();
			module = module.parentModule || currentModule;
		}

		setCurrentModule( module );

		function createModule() {
			var parentModule = config.moduleStack.length ?
				config.moduleStack.slice( -1 )[ 0 ] : null;
			var moduleName = parentModule !== null ?
				[ parentModule.name, name ].join( &quot; &gt; &quot; ) : name;
			var module = {
				name: moduleName,
				parentModule: parentModule,
				tests: [],
				moduleId: generateHash( moduleName ),
				testsRun: 0
			};

			var env = {};
			if ( parentModule ) {
				parentModule.childModule = module;
				extend( env, parentModule.testEnvironment );
				delete env.beforeEach;
				delete env.afterEach;
			}
			extend( env, testEnvironment );
			module.testEnvironment = env;

			config.modules.push( module );
			return module;
		}

		function setCurrentModule( module ) {
			config.currentModule = module;
		}

	},

	test: test,

	skip: skip,

	only: only,

	start: function( count ) {
		var globalStartAlreadyCalled = globalStartCalled;

		if ( !config.current ) {
			globalStartCalled = true;

			if ( runStarted ) {
				throw new Error( &quot;Called start() while test already started running&quot; );
			} else if ( globalStartAlreadyCalled || count &gt; 1 ) {
				throw new Error( &quot;Called start() outside of a test context too many times&quot; );
			} else if ( config.autostart ) {
				throw new Error( &quot;Called start() outside of a test context when &quot; +
					&quot;QUnit.config.autostart was true&quot; );
			} else if ( !config.pageLoaded ) {

				// The page isn&apos;t completely loaded yet, so bail out and let `QUnit.load` handle it
				config.autostart = true;
				return;
			}
		} else {
			throw new Error(
				&quot;QUnit.start cannot be called inside a test context. This feature is removed in &quot; +
				&quot;QUnit 2.0. For async tests, use QUnit.test() with assert.async() instead.\n&quot; +
				&quot;Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/&quot;
			);
		}

		scheduleBegin();
	},

	config: config,

	is: is,

	objectType: objectType,

	extend: extend,

	load: function() {
		config.pageLoaded = true;

		// Initialize the configuration options
		extend( config, {
			stats: { all: 0, bad: 0 },
			moduleStats: { all: 0, bad: 0 },
			started: 0,
			updateRate: 1000,
			autostart: true,
			filter: &quot;&quot;
		}, true );

		if ( !runStarted ) {
			config.blocking = false;

			if ( config.autostart ) {
				scheduleBegin();
			}
		}
	},

	stack: function( offset ) {
		offset = ( offset || 0 ) + 2;
		return sourceFromStacktrace( offset );
	}
} );

registerLoggingCallbacks( QUnit );

function scheduleBegin() {

	runStarted = true;

	// Add a slight delay to allow definition of more modules and tests.
	if ( defined.setTimeout ) {
		setTimeout( function() {
			begin();
		}, 13 );
	} else {
		begin();
	}
}

function begin() {
	var i, l,
		modulesLog = [];

	// If the test run hasn&apos;t officially begun yet
	if ( !config.started ) {

		// Record the time of the test run&apos;s beginning
		config.started = now();

		// Delete the loose unnamed module if unused.
		if ( config.modules[ 0 ].name === &quot;&quot; &amp;&amp; config.modules[ 0 ].tests.length === 0 ) {
			config.modules.shift();
		}

		// Avoid unnecessary information by not logging modules&apos; test environments
		for ( i = 0, l = config.modules.length; i &lt; l; i++ ) {
			modulesLog.push( {
				name: config.modules[ i ].name,
				tests: config.modules[ i ].tests
			} );
		}

		// The test run is officially beginning now
		runLoggingCallbacks( &quot;begin&quot;, {
			totalTests: Test.count,
			modules: modulesLog
		} );
	}

	config.blocking = false;
	process( true );
}

function process( last ) {
	function next() {
		process( last );
	}
	var start = now();
	config.depth = ( config.depth || 0 ) + 1;

	while ( config.queue.length &amp;&amp; !config.blocking ) {
		if ( !defined.setTimeout || config.updateRate &lt;= 0 ||
				( ( now() - start ) &lt; config.updateRate ) ) {
			if ( config.current ) {

				// Reset async tracking for each phase of the Test lifecycle
				config.current.usedAsync = false;
			}
			config.queue.shift()();
		} else {
			setTimeout( next, 13 );
			break;
		}
	}
	config.depth--;
	if ( last &amp;&amp; !config.blocking &amp;&amp; !config.queue.length &amp;&amp; config.depth === 0 ) {
		done();
	}
}

function done() {
	var runtime, passed;

	autorun = true;

	// Log the last module results
	if ( config.previousModule ) {
		runLoggingCallbacks( &quot;moduleDone&quot;, {
			name: config.previousModule.name,
			tests: config.previousModule.tests,
			failed: config.moduleStats.bad,
			passed: config.moduleStats.all - config.moduleStats.bad,
			total: config.moduleStats.all,
			runtime: now() - config.moduleStats.started
		} );
	}
	delete config.previousModule;

	runtime = now() - config.started;
	passed = config.stats.all - config.stats.bad;

	runLoggingCallbacks( &quot;done&quot;, {
		failed: config.stats.bad,
		passed: passed,
		total: config.stats.all,
		runtime: runtime
	} );
}

function setHook( module, hookName ) {
	if ( module.testEnvironment === undefined ) {
		module.testEnvironment = {};
	}

	return function( callback ) {
		module.testEnvironment[ hookName ] = callback;
	};
}

var unitSampler,
	focused = false,
	priorityCount = 0;

function Test( settings ) {
	var i, l;

	++Test.count;

	this.expected = null;
	extend( this, settings );
	this.assertions = [];
	this.semaphore = 0;
	this.usedAsync = false;
	this.module = config.currentModule;
	this.stack = sourceFromStacktrace( 3 );

	// Register unique strings
	for ( i = 0, l = this.module.tests; i &lt; l.length; i++ ) {
		if ( this.module.tests[ i ].name === this.testName ) {
			this.testName += &quot; &quot;;
		}
	}

	this.testId = generateHash( this.module.name, this.testName );

	this.module.tests.push( {
		name: this.testName,
		testId: this.testId
	} );

	if ( settings.skip ) {

		// Skipped tests will fully ignore any sent callback
		this.callback = function() {};
		this.async = false;
		this.expected = 0;
	} else {
		this.assert = new Assert( this );
	}
}

Test.count = 0;

Test.prototype = {
	before: function() {
		if (

			// Emit moduleStart when we&apos;re switching from one module to another
			this.module !== config.previousModule ||

				// They could be equal (both undefined) but if the previousModule property doesn&apos;t
				// yet exist it means this is the first test in a suite that isn&apos;t wrapped in a
				// module, in which case we&apos;ll just emit a moduleStart event for &apos;undefined&apos;.
				// Without this, reporters can get testStart before moduleStart  which is a problem.
				!hasOwn.call( config, &quot;previousModule&quot; )
		) {
			if ( hasOwn.call( config, &quot;previousModule&quot; ) ) {
				runLoggingCallbacks( &quot;moduleDone&quot;, {
					name: config.previousModule.name,
					tests: config.previousModule.tests,
					failed: config.moduleStats.bad,
					passed: config.moduleStats.all - config.moduleStats.bad,
					total: config.moduleStats.all,
					runtime: now() - config.moduleStats.started
				} );
			}
			config.previousModule = this.module;
			config.moduleStats = { all: 0, bad: 0, started: now() };
			runLoggingCallbacks( &quot;moduleStart&quot;, {
				name: this.module.name,
				tests: this.module.tests
			} );
		}

		config.current = this;

		if ( this.module.testEnvironment ) {
			delete this.module.testEnvironment.before;
			delete this.module.testEnvironment.beforeEach;
			delete this.module.testEnvironment.afterEach;
			delete this.module.testEnvironment.after;
		}
		this.testEnvironment = extend( {}, this.module.testEnvironment );

		this.started = now();
		runLoggingCallbacks( &quot;testStart&quot;, {
			name: this.testName,
			module: this.module.name,
			testId: this.testId
		} );

		if ( !config.pollution ) {
			saveGlobal();
		}
	},

	run: function() {
		var promise;

		config.current = this;

		this.callbackStarted = now();

		if ( config.notrycatch ) {
			runTest( this );
			return;
		}

		try {
			runTest( this );
		} catch ( e ) {
			this.pushFailure( &quot;Died on test #&quot; + ( this.assertions.length + 1 ) + &quot; &quot; +
				this.stack + &quot;: &quot; + ( e.message || e ), extractStacktrace( e, 0 ) );

			// Else next test will carry the responsibility
			saveGlobal();

			// Restart the tests if they&apos;re blocking
			if ( config.blocking ) {
				internalRecover( this );
			}
		}

		function runTest( test ) {
			promise = test.callback.call( test.testEnvironment, test.assert );
			test.resolvePromise( promise );
		}
	},

	after: function() {
		checkPollution();
	},

	queueHook: function( hook, hookName, hookOwner ) {
		var promise,
			test = this;
		return function runHook() {
			if ( hookName === &quot;before&quot; ) {
				if ( hookOwner.testsRun !== 0 ) {
					return;
				}

				test.preserveEnvironment = true;
			}

			if ( hookName === &quot;after&quot; &amp;&amp; hookOwner.testsRun !== numberOfTests( hookOwner ) - 1 ) {
				return;
			}

			config.current = test;
			if ( config.notrycatch ) {
				callHook();
				return;
			}
			try {
				callHook();
			} catch ( error ) {
				test.pushFailure( hookName + &quot; failed on &quot; + test.testName + &quot;: &quot; +
				( error.message || error ), extractStacktrace( error, 0 ) );
			}

			function callHook() {
				promise = hook.call( test.testEnvironment, test.assert );
				test.resolvePromise( promise, hookName );
			}
		};
	},

	// Currently only used for module level hooks, can be used to add global level ones
	hooks: function( handler ) {
		var hooks = [];

		function processHooks( test, module ) {
			if ( module.parentModule ) {
				processHooks( test, module.parentModule );
			}
			if ( module.testEnvironment &amp;&amp;
				QUnit.objectType( module.testEnvironment[ handler ] ) === &quot;function&quot; ) {
				hooks.push( test.queueHook( module.testEnvironment[ handler ], handler, module ) );
			}
		}

		// Hooks are ignored on skipped tests
		if ( !this.skip ) {
			processHooks( this, this.module );
		}
		return hooks;
	},

	finish: function() {
		config.current = this;
		if ( config.requireExpects &amp;&amp; this.expected === null ) {
			this.pushFailure( &quot;Expected number of assertions to be defined, but expect() was &quot; +
				&quot;not called.&quot;, this.stack );
		} else if ( this.expected !== null &amp;&amp; this.expected !== this.assertions.length ) {
			this.pushFailure( &quot;Expected &quot; + this.expected + &quot; assertions, but &quot; +
				this.assertions.length + &quot; were run&quot;, this.stack );
		} else if ( this.expected === null &amp;&amp; !this.assertions.length ) {
			this.pushFailure( &quot;Expected at least one assertion, but none were run - call &quot; +
				&quot;expect(0) to accept zero assertions.&quot;, this.stack );
		}

		var i,
			skipped = !!this.skip,
			bad = 0;

		this.runtime = now() - this.started;

		config.stats.all += this.assertions.length;
		config.moduleStats.all += this.assertions.length;

		for ( i = 0; i &lt; this.assertions.length; i++ ) {
			if ( !this.assertions[ i ].result ) {
				bad++;
				config.stats.bad++;
				config.moduleStats.bad++;
			}
		}

		notifyTestsRan( this.module );
		runLoggingCallbacks( &quot;testDone&quot;, {
			name: this.testName,
			module: this.module.name,
			skipped: skipped,
			failed: bad,
			passed: this.assertions.length - bad,
			total: this.assertions.length,
			runtime: skipped ? 0 : this.runtime,

			// HTML Reporter use
			assertions: this.assertions,
			testId: this.testId,

			// Source of Test
			source: this.stack
		} );

		config.current = undefined;
	},

	preserveTestEnvironment: function() {
		if ( this.preserveEnvironment ) {
			this.module.testEnvironment = this.testEnvironment;
			this.testEnvironment = extend( {}, this.module.testEnvironment );
		}
	},

	queue: function() {
		var priority,
			test = this;

		if ( !this.valid() ) {
			return;
		}

		function run() {

			// Each of these can by async
			synchronize( [
				function() {
					test.before();
				},

				test.hooks( &quot;before&quot; ),

				function() {
					test.preserveTestEnvironment();
				},

				test.hooks( &quot;beforeEach&quot; ),

				function() {
					test.run();
				},

				test.hooks( &quot;afterEach&quot; ).reverse(),
				test.hooks( &quot;after&quot; ).reverse(),

				function() {
					test.after();
				},

				function() {
					test.finish();
				}
			] );
		}

		// Prioritize previously failed tests, detected from sessionStorage
		priority = QUnit.config.reorder &amp;&amp; defined.sessionStorage &amp;&amp;
				+sessionStorage.getItem( &quot;qunit-test-&quot; + this.module.name + &quot;-&quot; + this.testName );

		return synchronize( run, priority, config.seed );
	},

	pushResult: function( resultInfo ) {

		// Destructure of resultInfo = { result, actual, expected, message, negative }
		var source,
			details = {
				module: this.module.name,
				name: this.testName,
				result: resultInfo.result,
				message: resultInfo.message,
				actual: resultInfo.actual,
				expected: resultInfo.expected,
				testId: this.testId,
				negative: resultInfo.negative || false,
				runtime: now() - this.started
			};

		if ( !resultInfo.result ) {
			source = sourceFromStacktrace();

			if ( source ) {
				details.source = source;
			}
		}

		runLoggingCallbacks( &quot;log&quot;, details );

		this.assertions.push( {
			result: !!resultInfo.result,
			message: resultInfo.message
		} );
	},

	pushFailure: function( message, source, actual ) {
		if ( !( this instanceof Test ) ) {
			throw new Error( &quot;pushFailure() assertion outside test context, was &quot; +
				sourceFromStacktrace( 2 ) );
		}

		var details = {
				module: this.module.name,
				name: this.testName,
				result: false,
				message: message || &quot;error&quot;,
				actual: actual || null,
				testId: this.testId,
				runtime: now() - this.started
			};

		if ( source ) {
			details.source = source;
		}

		runLoggingCallbacks( &quot;log&quot;, details );

		this.assertions.push( {
			result: false,
			message: message
		} );
	},

	resolvePromise: function( promise, phase ) {
		var then, resume, message,
			test = this;
		if ( promise != null ) {
			then = promise.then;
			if ( QUnit.objectType( then ) === &quot;function&quot; ) {
				resume = internalStop( test );
				then.call(
					promise,
					function() { resume(); },
					function( error ) {
						message = &quot;Promise rejected &quot; +
							( !phase ? &quot;during&quot; : phase.replace( /Each$/, &quot;&quot; ) ) +
							&quot; &quot; + test.testName + &quot;: &quot; + ( error.message || error );
						test.pushFailure( message, extractStacktrace( error, 0 ) );

						// Else next test will carry the responsibility
						saveGlobal();

						// Unblock
						resume();
					}
				);
			}
		}
	},

	valid: function() {
		var filter = config.filter,
			regexFilter = /^(!?)\/([\w\W]*)\/(i?$)/.exec( filter ),
			module = config.module &amp;&amp; config.module.toLowerCase(),
			fullName = ( this.module.name + &quot;: &quot; + this.testName );

		function moduleChainNameMatch( testModule ) {
			var testModuleName = testModule.name ? testModule.name.toLowerCase() : null;
			if ( testModuleName === module ) {
				return true;
			} else if ( testModule.parentModule ) {
				return moduleChainNameMatch( testModule.parentModule );
			} else {
				return false;
			}
		}

		function moduleChainIdMatch( testModule ) {
			return inArray( testModule.moduleId, config.moduleId ) &gt; -1 ||
				testModule.parentModule &amp;&amp; moduleChainIdMatch( testModule.parentModule );
		}

		// Internally-generated tests are always valid
		if ( this.callback &amp;&amp; this.callback.validTest ) {
			return true;
		}

		if ( config.moduleId &amp;&amp; config.moduleId.length &gt; 0 &amp;&amp;
			!moduleChainIdMatch( this.module ) ) {

			return false;
		}

		if ( config.testId &amp;&amp; config.testId.length &gt; 0 &amp;&amp;
			inArray( this.testId, config.testId ) &lt; 0 ) {

			return false;
		}

		if ( module &amp;&amp; !moduleChainNameMatch( this.module ) ) {
			return false;
		}

		if ( !filter ) {
			return true;
		}

		return regexFilter ?
			this.regexFilter( !!regexFilter[ 1 ], regexFilter[ 2 ], regexFilter[ 3 ], fullName ) :
			this.stringFilter( filter, fullName );
	},

	regexFilter: function( exclude, pattern, flags, fullName ) {
		var regex = new RegExp( pattern, flags );
		var match = regex.test( fullName );

		return match !== exclude;
	},

	stringFilter: function( filter, fullName ) {
		filter = filter.toLowerCase();
		fullName = fullName.toLowerCase();

		var include = filter.charAt( 0 ) !== &quot;!&quot;;
		if ( !include ) {
			filter = filter.slice( 1 );
		}

		// If the filter matches, we need to honour include
		if ( fullName.indexOf( filter ) !== -1 ) {
			return include;
		}

		// Otherwise, do the opposite
		return !include;
	}
};

QUnit.pushFailure = function() {
	if ( !QUnit.config.current ) {
		throw new Error( &quot;pushFailure() assertion outside test context, in &quot; +
			sourceFromStacktrace( 2 ) );
	}

	// Gets current test obj
	var currentTest = QUnit.config.current;

	return currentTest.pushFailure.apply( currentTest, arguments );
};

// Based on Java&apos;s String.hashCode, a simple but not
// rigorously collision resistant hashing function
function generateHash( module, testName ) {
	var hex,
		i = 0,
		hash = 0,
		str = module + &quot;\x1C&quot; + testName,
		len = str.length;

	for ( ; i &lt; len; i++ ) {
		hash  = ( ( hash &lt;&lt; 5 ) - hash ) + str.charCodeAt( i );
		hash |= 0;
	}

	// Convert the possibly negative integer hash code into an 8 character hex string, which isn&apos;t
	// strictly necessary but increases user understanding that the id is a SHA-like hash
	hex = ( 0x100000000 + hash ).toString( 16 );
	if ( hex.length &lt; 8 ) {
		hex = &quot;0000000&quot; + hex;
	}

	return hex.slice( -8 );
}

function synchronize( callback, priority, seed ) {
	var last = !priority,
		index;

	if ( QUnit.objectType( callback ) === &quot;array&quot; ) {
		while ( callback.length ) {
			synchronize( callback.shift() );
		}
		return;
	}

	if ( priority ) {
		config.queue.splice( priorityCount++, 0, callback );
	} else if ( seed ) {
		if ( !unitSampler ) {
			unitSampler = unitSamplerGenerator( seed );
		}

		// Insert into a random position after all priority items
		index = Math.floor( unitSampler() * ( config.queue.length - priorityCount + 1 ) );
		config.queue.splice( priorityCount + index, 0, callback );
	} else {
		config.queue.push( callback );
	}

	if ( autorun &amp;&amp; !config.blocking ) {
		process( last );
	}
}

function unitSamplerGenerator( seed ) {

	// 32-bit xorshift, requires only a nonzero seed
	// http://excamera.com/sphinx/article-xorshift.html
	var sample = parseInt( generateHash( seed ), 16 ) || -1;
	return function() {
		sample ^= sample &lt;&lt; 13;
		sample ^= sample &gt;&gt;&gt; 17;
		sample ^= sample &lt;&lt; 5;

		// ECMAScript has no unsigned number type
		if ( sample &lt; 0 ) {
			sample += 0x100000000;
		}

		return sample / 0x100000000;
	};
}

function saveGlobal() {
	config.pollution = [];

	if ( config.noglobals ) {
		for ( var key in global ) {
			if ( hasOwn.call( global, key ) ) {

				// In Opera sometimes DOM element ids show up here, ignore them
				if ( /^qunit-test-output/.test( key ) ) {
					continue;
				}
				config.pollution.push( key );
			}
		}
	}
}

function checkPollution() {
	var newGlobals,
		deletedGlobals,
		old = config.pollution;

	saveGlobal();

	newGlobals = diff( config.pollution, old );
	if ( newGlobals.length &gt; 0 ) {
		QUnit.pushFailure( &quot;Introduced global variable(s): &quot; + newGlobals.join( &quot;, &quot; ) );
	}

	deletedGlobals = diff( old, config.pollution );
	if ( deletedGlobals.length &gt; 0 ) {
		QUnit.pushFailure( &quot;Deleted global variable(s): &quot; + deletedGlobals.join( &quot;, &quot; ) );
	}
}

// Will be exposed as QUnit.test
function test( testName, callback ) {
	if ( focused )  { return; }

	var newTest;

	newTest = new Test( {
		testName: testName,
		callback: callback
	} );

	newTest.queue();
}

// Will be exposed as QUnit.skip
function skip( testName ) {
	if ( focused )  { return; }

	var test = new Test( {
		testName: testName,
		skip: true
	} );

	test.queue();
}

// Will be exposed as QUnit.only
function only( testName, callback ) {
	var newTest;

	if ( focused )  { return; }

	QUnit.config.queue.length = 0;
	focused = true;

	newTest = new Test( {
		testName: testName,
		callback: callback
	} );

	newTest.queue();
}

// Put a hold on processing and return a function that will release it.
function internalStop( test ) {
	var released = false;

	test.semaphore += 1;
	config.blocking = true;

	// Set a recovery timeout, if so configured.
	if ( config.testTimeout &amp;&amp; defined.setTimeout ) {
		clearTimeout( config.timeout );
		config.timeout = setTimeout( function() {
			QUnit.pushFailure( &quot;Test timed out&quot;, sourceFromStacktrace( 2 ) );
			internalRecover( test );
		}, config.testTimeout );
	}

	return function resume() {
		if ( released ) {
			return;
		}

		released = true;
		test.semaphore -= 1;
		internalStart( test );
	};
}

// Forcefully release all processing holds.
function internalRecover( test ) {
	test.semaphore = 0;
	internalStart( test );
}

// Release a processing hold, scheduling a resumption attempt if no holds remain.
function internalStart( test ) {

	// If semaphore is non-numeric, throw error
	if ( isNaN( test.semaphore ) ) {
		test.semaphore = 0;

		QUnit.pushFailure(
			&quot;Invalid value on test.semaphore&quot;,
			sourceFromStacktrace( 2 )
		);
		return;
	}

	// Don&apos;t start until equal number of stop-calls
	if ( test.semaphore &gt; 0 ) {
		return;
	}

	// Throw an Error if start is called more often than stop
	if ( test.semaphore &lt; 0 ) {
		test.semaphore = 0;

		QUnit.pushFailure(
			&quot;Tried to restart test while already started (test&apos;s semaphore was 0 already)&quot;,
			sourceFromStacktrace( 2 )
		);
		return;
	}

	// Add a slight delay to allow more assertions etc.
	if ( defined.setTimeout ) {
		if ( config.timeout ) {
			clearTimeout( config.timeout );
		}
		config.timeout = setTimeout( function() {
			if ( test.semaphore &gt; 0 ) {
				return;
			}

			if ( config.timeout ) {
				clearTimeout( config.timeout );
			}

			begin();
		}, 13 );
	} else {
		begin();
	}
}

function numberOfTests( module ) {
	var count = module.tests.length;
	while ( module = module.childModule ) {
		count += module.tests.length;
	}
	return count;
}

function notifyTestsRan( module ) {
	module.testsRun++;
	while ( module = module.parentModule ) {
		module.testsRun++;
	}
}

function Assert( testContext ) {
	this.test = testContext;
}

// Assert helpers
QUnit.assert = Assert.prototype = {

	// Specify the number of expected assertions to guarantee that failed test
	// (no assertions are run at all) don&apos;t slip through.
	expect: function( asserts ) {
		if ( arguments.length === 1 ) {
			this.test.expected = asserts;
		} else {
			return this.test.expected;
		}
	},

	// Put a hold on processing and return a function that will release it a maximum of once.
	async: function( count ) {
		var resume,
			test = this.test,
			popped = false,
			acceptCallCount = count;

		if ( typeof acceptCallCount === &quot;undefined&quot; ) {
			acceptCallCount = 1;
		}

		test.usedAsync = true;
		resume = internalStop( test );

		return function done() {

			if ( popped ) {
				test.pushFailure( &quot;Too many calls to the `assert.async` callback&quot;,
					sourceFromStacktrace( 2 ) );
				return;
			}
			acceptCallCount -= 1;
			if ( acceptCallCount &gt; 0 ) {
				return;
			}

			popped = true;
			resume();
		};
	},

	// Exports test.push() to the user API
	// Alias of pushResult.
	push: function( result, actual, expected, message, negative ) {
		var currentAssert = this instanceof Assert ? this : QUnit.config.current.assert;
		return currentAssert.pushResult( {
			result: result,
			actual: actual,
			expected: expected,
			message: message,
			negative: negative
		} );
	},

	pushResult: function( resultInfo ) {

		// Destructure of resultInfo = { result, actual, expected, message, negative }
		var assert = this,
			currentTest = ( assert instanceof Assert &amp;&amp; assert.test ) || QUnit.config.current;

		// Backwards compatibility fix.
		// Allows the direct use of global exported assertions and QUnit.assert.*
		// Although, it&apos;s use is not recommended as it can leak assertions
		// to other tests from async tests, because we only get a reference to the current test,
		// not exactly the test where assertion were intended to be called.
		if ( !currentTest ) {
			throw new Error( &quot;assertion outside test context, in &quot; + sourceFromStacktrace( 2 ) );
		}

		if ( currentTest.usedAsync === true &amp;&amp; currentTest.semaphore === 0 ) {
			currentTest.pushFailure( &quot;Assertion after the final `assert.async` was resolved&quot;,
				sourceFromStacktrace( 2 ) );

			// Allow this assertion to continue running anyway...
		}

		if ( !( assert instanceof Assert ) ) {
			assert = currentTest.assert;
		}

		return assert.test.pushResult( resultInfo );
	},

	ok: function( result, message ) {
		message = message || ( result ? &quot;okay&quot; : &quot;failed, expected argument to be truthy, was: &quot; +
			QUnit.dump.parse( result ) );
		this.pushResult( {
			result: !!result,
			actual: result,
			expected: true,
			message: message
		} );
	},

	notOk: function( result, message ) {
		message = message || ( !result ? &quot;okay&quot; : &quot;failed, expected argument to be falsy, was: &quot; +
			QUnit.dump.parse( result ) );
		this.pushResult( {
			result: !result,
			actual: result,
			expected: false,
			message: message
		} );
	},

	equal: function( actual, expected, message ) {
		/*jshint eqeqeq:false */
		this.pushResult( {
			result: expected == actual,
			actual: actual,
			expected: expected,
			message: message
		} );
	},

	notEqual: function( actual, expected, message ) {
		/*jshint eqeqeq:false */
		this.pushResult( {
			result: expected != actual,
			actual: actual,
			expected: expected,
			message: message,
			negative: true
		} );
	},

	propEqual: function( actual, expected, message ) {
		actual = objectValues( actual );
		expected = objectValues( expected );
		this.pushResult( {
			result: QUnit.equiv( actual, expected ),
			actual: actual,
			expected: expected,
			message: message
		} );
	},

	notPropEqual: function( actual, expected, message ) {
		actual = objectValues( actual );
		expected = objectValues( expected );
		this.pushResult( {
			result: !QUnit.equiv( actual, expected ),
			actual: actual,
			expected: expected,
			message: message,
			negative: true
		} );
	},

	deepEqual: function( actual, expected, message ) {
		this.pushResult( {
			result: QUnit.equiv( actual, expected ),
			actual: actual,
			expected: expected,
			message: message
		} );
	},

	notDeepEqual: function( actual, expected, message ) {
		this.pushResult( {
			result: !QUnit.equiv( actual, expected ),
			actual: actual,
			expected: expected,
			message: message,
			negative: true
		} );
	},

	strictEqual: function( actual, expected, message ) {
		this.pushResult( {
			result: expected === actual,
			actual: actual,
			expected: expected,
			message: message
		} );
	},

	notStrictEqual: function( actual, expected, message ) {
		this.pushResult( {
			result: expected !== actual,
			actual: actual,
			expected: expected,
			message: message,
			negative: true
		} );
	},

	&quot;throws&quot;: function( block, expected, message ) {
		var actual, expectedType,
			expectedOutput = expected,
			ok = false,
			currentTest = ( this instanceof Assert &amp;&amp; this.test ) || QUnit.config.current;

		// &apos;expected&apos; is optional unless doing string comparison
		if ( QUnit.objectType( expected ) === &quot;string&quot; ) {
			if ( message == null ) {
				message = expected;
				expected = null;
			} else {
				throw new Error(
					&quot;throws/raises does not accept a string value for the expected argument.\n&quot; +
					&quot;Use a non-string object value (e.g. regExp) instead if it&apos;s necessary.&quot; +
					&quot;Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/&quot;
				);
			}
		}

		currentTest.ignoreGlobalErrors = true;
		try {
			block.call( currentTest.testEnvironment );
		} catch ( e ) {
			actual = e;
		}
		currentTest.ignoreGlobalErrors = false;

		if ( actual ) {
			expectedType = QUnit.objectType( expected );

			// We don&apos;t want to validate thrown error
			if ( !expected ) {
				ok = true;
				expectedOutput = null;

			// Expected is a regexp
			} else if ( expectedType === &quot;regexp&quot; ) {
				ok = expected.test( errorString( actual ) );

			// Expected is a constructor, maybe an Error constructor
			} else if ( expectedType === &quot;function&quot; &amp;&amp; actual instanceof expected ) {
				ok = true;

			// Expected is an Error object
			} else if ( expectedType === &quot;object&quot; ) {
				ok = actual instanceof expected.constructor &amp;&amp;
					actual.name === expected.name &amp;&amp;
					actual.message === expected.message;

			// Expected is a validation function which returns true if validation passed
			} else if ( expectedType === &quot;function&quot; &amp;&amp; expected.call( {}, actual ) === true ) {
				expectedOutput = null;
				ok = true;
			}
		}

		currentTest.assert.pushResult( {
			result: ok,
			actual: actual,
			expected: expectedOutput,
			message: message
		} );
	}
};

// Provide an alternative to assert.throws(), for environments that consider throws a reserved word
// Known to us are: Closure Compiler, Narwhal
( function() {
	/*jshint sub:true */
	Assert.prototype.raises = Assert.prototype [ &quot;throws&quot; ]; //jscs:ignore requireDotNotation
}() );

function errorString( error ) {
	var name, message,
		resultErrorString = error.toString();
	if ( resultErrorString.substring( 0, 7 ) === &quot;[object&quot; ) {
		name = error.name ? error.name.toString() : &quot;Error&quot;;
		message = error.message ? error.message.toString() : &quot;&quot;;
		if ( name &amp;&amp; message ) {
			return name + &quot;: &quot; + message;
		} else if ( name ) {
			return name;
		} else if ( message ) {
			return message;
		} else {
			return &quot;Error&quot;;
		}
	} else {
		return resultErrorString;
	}
}

// Test for equality any JavaScript type.
// Author: Philippe Rath&#xE9; &lt;prathe@gmail.com&gt;
QUnit.equiv = ( function() {

	// Stack to decide between skip/abort functions
	var callers = [];

	// Stack to avoiding loops from circular referencing
	var parents = [];
	var parentsB = [];

	var getProto = Object.getPrototypeOf || function( obj ) {

		/*jshint proto: true */
		return obj.__proto__;
	};

	function useStrictEquality( b, a ) {

		// To catch short annotation VS &apos;new&apos; annotation of a declaration. e.g.:
		// `var i = 1;`
		// `var j = new Number(1);`
		if ( typeof a === &quot;object&quot; ) {
			a = a.valueOf();
		}
		if ( typeof b === &quot;object&quot; ) {
			b = b.valueOf();
		}

		return a === b;
	}

	function compareConstructors( a, b ) {
		var protoA = getProto( a );
		var protoB = getProto( b );

		// Comparing constructors is more strict than using `instanceof`
		if ( a.constructor === b.constructor ) {
			return true;
		}

		// Ref #851
		// If the obj prototype descends from a null constructor, treat it
		// as a null prototype.
		if ( protoA &amp;&amp; protoA.constructor === null ) {
			protoA = null;
		}
		if ( protoB &amp;&amp; protoB.constructor === null ) {
			protoB = null;
		}

		// Allow objects with no prototype to be equivalent to
		// objects with Object as their constructor.
		if ( ( protoA === null &amp;&amp; protoB === Object.prototype ) ||
				( protoB === null &amp;&amp; protoA === Object.prototype ) ) {
			return true;
		}

		return false;
	}

	function getRegExpFlags( regexp ) {
		return &quot;flags&quot; in regexp ? regexp.flags : regexp.toString().match( /[gimuy]*$/ )[ 0 ];
	}

	var callbacks = {
		&quot;string&quot;: useStrictEquality,
		&quot;boolean&quot;: useStrictEquality,
		&quot;number&quot;: useStrictEquality,
		&quot;null&quot;: useStrictEquality,
		&quot;undefined&quot;: useStrictEquality,
		&quot;symbol&quot;: useStrictEquality,
		&quot;date&quot;: useStrictEquality,

		&quot;nan&quot;: function() {
			return true;
		},

		&quot;regexp&quot;: function( b, a ) {
			return a.source === b.source &amp;&amp;

				// Include flags in the comparison
				getRegExpFlags( a ) === getRegExpFlags( b );
		},

		// - skip when the property is a method of an instance (OOP)
		// - abort otherwise,
		// initial === would have catch identical references anyway
		&quot;function&quot;: function() {
			var caller = callers[ callers.length - 1 ];
			return caller !== Object &amp;&amp; typeof caller !== &quot;undefined&quot;;
		},

		&quot;array&quot;: function( b, a ) {
			var i, j, len, loop, aCircular, bCircular;

			len = a.length;
			if ( len !== b.length ) {

				// Safe and faster
				return false;
			}

			// Track reference to avoid circular references
			parents.push( a );
			parentsB.push( b );
			for ( i = 0; i &lt; len; i++ ) {
				loop = false;
				for ( j = 0; j &lt; parents.length; j++ ) {
					aCircular = parents[ j ] === a[ i ];
					bCircular = parentsB[ j ] === b[ i ];
					if ( aCircular || bCircular ) {
						if ( a[ i ] === b[ i ] || aCircular &amp;&amp; bCircular ) {
							loop = true;
						} else {
							parents.pop();
							parentsB.pop();
							return false;
						}
					}
				}
				if ( !loop &amp;&amp; !innerEquiv( a[ i ], b[ i ] ) ) {
					parents.pop();
					parentsB.pop();
					return false;
				}
			}
			parents.pop();
			parentsB.pop();
			return true;
		},

		&quot;set&quot;: function( b, a ) {
			var innerEq,
				outerEq = true;

			if ( a.size !== b.size ) {
				return false;
			}

			a.forEach( function( aVal ) {
				innerEq = false;

				b.forEach( function( bVal ) {
					if ( innerEquiv( bVal, aVal ) ) {
						innerEq = true;
					}
				} );

				if ( !innerEq ) {
					outerEq = false;
				}
			} );

			return outerEq;
		},

		&quot;map&quot;: function( b, a ) {
			var innerEq,
				outerEq = true;

			if ( a.size !== b.size ) {
				return false;
			}

			a.forEach( function( aVal, aKey ) {
				innerEq = false;

				b.forEach( function( bVal, bKey ) {
					if ( innerEquiv( [ bVal, bKey ], [ aVal, aKey ] ) ) {
						innerEq = true;
					}
				} );

				if ( !innerEq ) {
					outerEq = false;
				}
			} );

			return outerEq;
		},

		&quot;object&quot;: function( b, a ) {
			var i, j, loop, aCircular, bCircular;

			// Default to true
			var eq = true;
			var aProperties = [];
			var bProperties = [];

			if ( compareConstructors( a, b ) === false ) {
				return false;
			}

			// Stack constructor before traversing properties
			callers.push( a.constructor );

			// Track reference to avoid circular references
			parents.push( a );
			parentsB.push( b );

			// Be strict: don&apos;t ensure hasOwnProperty and go deep
			for ( i in a ) {
				loop = false;
				for ( j = 0; j &lt; parents.length; j++ ) {
					aCircular = parents[ j ] === a[ i ];
					bCircular = parentsB[ j ] === b[ i ];
					if ( aCircular || bCircular ) {
						if ( a[ i ] === b[ i ] || aCircular &amp;&amp; bCircular ) {
							loop = true;
						} else {
							eq = false;
							break;
						}
					}
				}
				aProperties.push( i );
				if ( !loop &amp;&amp; !innerEquiv( a[ i ], b[ i ] ) ) {
					eq = false;
					break;
				}
			}

			parents.pop();
			parentsB.pop();

			// Unstack, we are done
			callers.pop();

			for ( i in b ) {

				// Collect b&apos;s properties
				bProperties.push( i );
			}

			// Ensures identical properties name
			return eq &amp;&amp; innerEquiv( aProperties.sort(), bProperties.sort() );
		}
	};

	function typeEquiv( a, b ) {
		var type = QUnit.objectType( a );
		return QUnit.objectType( b ) === type &amp;&amp; callbacks[ type ]( b, a );
	}

	// The real equiv function
	function innerEquiv( a, b ) {

		// We&apos;re done when there&apos;s nothing more to compare
		if ( arguments.length &lt; 2 ) {
			return true;
		}

		// Require type-specific equality
		return ( a === b || typeEquiv( a, b ) ) &amp;&amp;

			// ...across all consecutive argument pairs
			( arguments.length === 2 || innerEquiv.apply( this, [].slice.call( arguments, 1 ) ) );
	}

	return innerEquiv;
}() );

// Based on jsDump by Ariel Flesler
// http://flesler.blogspot.com/2008/05/jsdump-pretty-dump-of-any-javascript.html
QUnit.dump = ( function() {
	function quote( str ) {
		return &quot;\&quot;&quot; + str.toString().replace( /\\/g, &quot;\\\\&quot; ).replace( /&quot;/g, &quot;\\\&quot;&quot; ) + &quot;\&quot;&quot;;
	}
	function literal( o ) {
		return o + &quot;&quot;;
	}
	function join( pre, arr, post ) {
		var s = dump.separator(),
			base = dump.indent(),
			inner = dump.indent( 1 );
		if ( arr.join ) {
			arr = arr.join( &quot;,&quot; + s + inner );
		}
		if ( !arr ) {
			return pre + post;
		}
		return [ pre, inner + arr, base + post ].join( s );
	}
	function array( arr, stack ) {
		var i = arr.length,
			ret = new Array( i );

		if ( dump.maxDepth &amp;&amp; dump.depth &gt; dump.maxDepth ) {
			return &quot;[object Array]&quot;;
		}

		this.up();
		while ( i-- ) {
			ret[ i ] = this.parse( arr[ i ], undefined, stack );
		}
		this.down();
		return join( &quot;[&quot;, ret, &quot;]&quot; );
	}

	function isArray( obj ) {
		return (

			//Native Arrays
			toString.call( obj ) === &quot;[object Array]&quot; ||

			// NodeList objects
			( typeof obj.length === &quot;number&quot; &amp;&amp; obj.item !== undefined ) &amp;&amp;
			( obj.length ?
				obj.item( 0 ) === obj[ 0 ] :
				( obj.item( 0 ) === null &amp;&amp; obj[ 0 ] === undefined )
			)
		);
	}

	var reName = /^function (\w+)/,
		dump = {

			// The objType is used mostly internally, you can fix a (custom) type in advance
			parse: function( obj, objType, stack ) {
				stack = stack || [];
				var res, parser, parserType,
					inStack = inArray( obj, stack );

				if ( inStack !== -1 ) {
					return &quot;recursion(&quot; + ( inStack - stack.length ) + &quot;)&quot;;
				}

				objType = objType || this.typeOf( obj  );
				parser = this.parsers[ objType ];
				parserType = typeof parser;

				if ( parserType === &quot;function&quot; ) {
					stack.push( obj );
					res = parser.call( this, obj, stack );
					stack.pop();
					return res;
				}
				return ( parserType === &quot;string&quot; ) ? parser : this.parsers.error;
			},
			typeOf: function( obj ) {
				var type;

				if ( obj === null ) {
					type = &quot;null&quot;;
				} else if ( typeof obj === &quot;undefined&quot; ) {
					type = &quot;undefined&quot;;
				} else if ( QUnit.is( &quot;regexp&quot;, obj ) ) {
					type = &quot;regexp&quot;;
				} else if ( QUnit.is( &quot;date&quot;, obj ) ) {
					type = &quot;date&quot;;
				} else if ( QUnit.is( &quot;function&quot;, obj ) ) {
					type = &quot;function&quot;;
				} else if ( obj.setInterval !== undefined &amp;&amp;
						obj.document !== undefined &amp;&amp;
						obj.nodeType === undefined ) {
					type = &quot;window&quot;;
				} else if ( obj.nodeType === 9 ) {
					type = &quot;document&quot;;
				} else if ( obj.nodeType ) {
					type = &quot;node&quot;;
				} else if ( isArray( obj ) ) {
					type = &quot;array&quot;;
				} else if ( obj.constructor === Error.prototype.constructor ) {
					type = &quot;error&quot;;
				} else {
					type = typeof obj;
				}
				return type;
			},

			separator: function() {
				return this.multiline ? this.HTML ? &quot;&lt;br /&gt;&quot; : &quot;\n&quot; : this.HTML ? &quot;&amp;#160;&quot; : &quot; &quot;;
			},

			// Extra can be a number, shortcut for increasing-calling-decreasing
			indent: function( extra ) {
				if ( !this.multiline ) {
					return &quot;&quot;;
				}
				var chr = this.indentChar;
				if ( this.HTML ) {
					chr = chr.replace( /\t/g, &quot;   &quot; ).replace( / /g, &quot;&amp;#160;&quot; );
				}
				return new Array( this.depth + ( extra || 0 ) ).join( chr );
			},
			up: function( a ) {
				this.depth += a || 1;
			},
			down: function( a ) {
				this.depth -= a || 1;
			},
			setParser: function( name, parser ) {
				this.parsers[ name ] = parser;
			},

			// The next 3 are exposed so you can use them
			quote: quote,
			literal: literal,
			join: join,
			depth: 1,
			maxDepth: QUnit.config.maxDepth,

			// This is the list of parsers, to modify them, use dump.setParser
			parsers: {
				window: &quot;[Window]&quot;,
				document: &quot;[Document]&quot;,
				error: function( error ) {
					return &quot;Error(\&quot;&quot; + error.message + &quot;\&quot;)&quot;;
				},
				unknown: &quot;[Unknown]&quot;,
				&quot;null&quot;: &quot;null&quot;,
				&quot;undefined&quot;: &quot;undefined&quot;,
				&quot;function&quot;: function( fn ) {
					var ret = &quot;function&quot;,

						// Functions never have name in IE
						name = &quot;name&quot; in fn ? fn.name : ( reName.exec( fn ) || [] )[ 1 ];

					if ( name ) {
						ret += &quot; &quot; + name;
					}
					ret += &quot;(&quot;;

					ret = [ ret, dump.parse( fn, &quot;functionArgs&quot; ), &quot;){&quot; ].join( &quot;&quot; );
					return join( ret, dump.parse( fn, &quot;functionCode&quot; ), &quot;}&quot; );
				},
				array: array,
				nodelist: array,
				&quot;arguments&quot;: array,
				object: function( map, stack ) {
					var keys, key, val, i, nonEnumerableProperties,
						ret = [];

					if ( dump.maxDepth &amp;&amp; dump.depth &gt; dump.maxDepth ) {
						return &quot;[object Object]&quot;;
					}

					dump.up();
					keys = [];
					for ( key in map ) {
						keys.push( key );
					}

					// Some properties are not always enumerable on Error objects.
					nonEnumerableProperties = [ &quot;message&quot;, &quot;name&quot; ];
					for ( i in nonEnumerableProperties ) {
						key = nonEnumerableProperties[ i ];
						if ( key in map &amp;&amp; inArray( key, keys ) &lt; 0 ) {
							keys.push( key );
						}
					}
					keys.sort();
					for ( i = 0; i &lt; keys.length; i++ ) {
						key = keys[ i ];
						val = map[ key ];
						ret.push( dump.parse( key, &quot;key&quot; ) + &quot;: &quot; +
							dump.parse( val, undefined, stack ) );
					}
					dump.down();
					return join( &quot;{&quot;, ret, &quot;}&quot; );
				},
				node: function( node ) {
					var len, i, val,
						open = dump.HTML ? &quot;&amp;lt;&quot; : &quot;&lt;&quot;,
						close = dump.HTML ? &quot;&amp;gt;&quot; : &quot;&gt;&quot;,
						tag = node.nodeName.toLowerCase(),
						ret = open + tag,
						attrs = node.attributes;

					if ( attrs ) {
						for ( i = 0, len = attrs.length; i &lt; len; i++ ) {
							val = attrs[ i ].nodeValue;

							// IE6 includes all attributes in .attributes, even ones not explicitly
							// set. Those have values like undefined, null, 0, false, &quot;&quot; or
							// &quot;inherit&quot;.
							if ( val &amp;&amp; val !== &quot;inherit&quot; ) {
								ret += &quot; &quot; + attrs[ i ].nodeName + &quot;=&quot; +
									dump.parse( val, &quot;attribute&quot; );
							}
						}
					}
					ret += close;

					// Show content of TextNode or CDATASection
					if ( node.nodeType === 3 || node.nodeType === 4 ) {
						ret += node.nodeValue;
					}

					return ret + open + &quot;/&quot; + tag + close;
				},

				// Function calls it internally, it&apos;s the arguments part of the function
				functionArgs: function( fn ) {
					var args,
						l = fn.length;

					if ( !l ) {
						return &quot;&quot;;
					}

					args = new Array( l );
					while ( l-- ) {

						// 97 is &apos;a&apos;
						args[ l ] = String.fromCharCode( 97 + l );
					}
					return &quot; &quot; + args.join( &quot;, &quot; ) + &quot; &quot;;
				},

				// Object calls it internally, the key part of an item in a map
				key: quote,

				// Function calls it internally, it&apos;s the content of the function
				functionCode: &quot;[code]&quot;,

				// Node calls it internally, it&apos;s a html attribute value
				attribute: quote,
				string: quote,
				date: quote,
				regexp: literal,
				number: literal,
				&quot;boolean&quot;: literal,
				symbol: function( sym ) {
					return sym.toString();
				}
			},

			// If true, entities are escaped ( &lt;, &gt;, \t, space and \n )
			HTML: false,

			// Indentation unit
			indentChar: &quot;  &quot;,

			// If true, items in a collection, are separated by a \n, else just a space.
			multiline: true
		};

	return dump;
}() );

// Back compat
QUnit.jsDump = QUnit.dump;

function applyDeprecated( name ) {
	return function() {
		throw new Error(
			name + &quot; is removed in QUnit 2.0.\n&quot; +
			&quot;Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/&quot;
		);
	};
}

Object.keys( Assert.prototype ).forEach( function( key ) {
	QUnit[ key ] = applyDeprecated( &quot;`QUnit.&quot; + key + &quot;`&quot; );
} );

QUnit.asyncTest = function() {
	throw new Error(
		&quot;asyncTest is removed in QUnit 2.0, use QUnit.test() with assert.async() instead.\n&quot; +
		&quot;Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/&quot;
	);
};

QUnit.stop = function() {
	throw new Error(
		&quot;QUnit.stop is removed in QUnit 2.0, use QUnit.test() with assert.async() instead.\n&quot; +
		&quot;Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/&quot;
	);
};

function resetThrower() {
	throw new Error(
		&quot;QUnit.reset is removed in QUnit 2.0 without replacement.\n&quot; +
		&quot;Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/&quot;
	);
}

Object.defineProperty( QUnit, &quot;reset&quot;, {
	get: function() {
		return resetThrower;
	},
	set: resetThrower
} );

if ( defined.document ) {
	if ( window.QUnit ) {
		throw new Error( &quot;QUnit has already been defined.&quot; );
	}

	[
		&quot;test&quot;,
		&quot;module&quot;,
		&quot;expect&quot;,
		&quot;start&quot;,
		&quot;ok&quot;,
		&quot;notOk&quot;,
		&quot;equal&quot;,
		&quot;notEqual&quot;,
		&quot;propEqual&quot;,
		&quot;notPropEqual&quot;,
		&quot;deepEqual&quot;,
		&quot;notDeepEqual&quot;,
		&quot;strictEqual&quot;,
		&quot;notStrictEqual&quot;,
		&quot;throws&quot;,
		&quot;raises&quot;
	].forEach( function( key ) {
		window[ key ] = applyDeprecated( &quot;The global `&quot; + key + &quot;`&quot; );
	} );

	window.QUnit = QUnit;
}

// For nodejs
if ( typeof module !== &quot;undefined&quot; &amp;&amp; module &amp;&amp; module.exports ) {
	module.exports = QUnit;

	// For consistency with CommonJS environments&apos; exports
	module.exports.QUnit = QUnit;
}

// For CommonJS with exports, but without module.exports, like Rhino
if ( typeof exports !== &quot;undefined&quot; &amp;&amp; exports ) {
	exports.QUnit = QUnit;
}

if ( typeof define === &quot;function&quot; &amp;&amp; define.amd ) {
	define( function() {
		return QUnit;
	} );
	QUnit.config.autostart = false;
}

// Get a reference to the global object, like window in browsers
}( ( function() {
	return this;
}() ) ) );

( function() {

if ( typeof window === &quot;undefined&quot; || !window.document ) {
	return;
}

var config = QUnit.config,
	hasOwn = Object.prototype.hasOwnProperty;

// Stores fixture HTML for resetting later
function storeFixture() {

	// Avoid overwriting user-defined values
	if ( hasOwn.call( config, &quot;fixture&quot; ) ) {
		return;
	}

	var fixture = document.getElementById( &quot;qunit-fixture&quot; );
	if ( fixture ) {
		config.fixture = fixture.innerHTML;
	}
}

QUnit.begin( storeFixture );

// Resets the fixture DOM element if available.
function resetFixture() {
	if ( config.fixture == null ) {
		return;
	}

	var fixture = document.getElementById( &quot;qunit-fixture&quot; );
	if ( fixture ) {
		fixture.innerHTML = config.fixture;
	}
}

QUnit.testStart( resetFixture );

}() );

( function() {

// Only interact with URLs via window.location
var location = typeof window !== &quot;undefined&quot; &amp;&amp; window.location;
if ( !location ) {
	return;
}

var urlParams = getUrlParams();

QUnit.urlParams = urlParams;

// Match module/test by inclusion in an array
QUnit.config.moduleId = [].concat( urlParams.moduleId || [] );
QUnit.config.testId = [].concat( urlParams.testId || [] );

// Exact case-insensitive match of the module name
QUnit.config.module = urlParams.module;

// Regular expression or case-insenstive substring match against &quot;moduleName: testName&quot;
QUnit.config.filter = urlParams.filter;

// Test order randomization
if ( urlParams.seed === true ) {

	// Generate a random seed if the option is specified without a value
	QUnit.config.seed = Math.random().toString( 36 ).slice( 2 );
} else if ( urlParams.seed ) {
	QUnit.config.seed = urlParams.seed;
}

// Add URL-parameter-mapped config values with UI form rendering data
QUnit.config.urlConfig.push(
	{
		id: &quot;hidepassed&quot;,
		label: &quot;Hide passed tests&quot;,
		tooltip: &quot;Only show tests and assertions that fail. Stored as query-strings.&quot;
	},
	{
		id: &quot;noglobals&quot;,
		label: &quot;Check for Globals&quot;,
		tooltip: &quot;Enabling this will test if any test introduces new properties on the &quot; +
			&quot;global object (`window` in Browsers). Stored as query-strings.&quot;
	},
	{
		id: &quot;notrycatch&quot;,
		label: &quot;No try-catch&quot;,
		tooltip: &quot;Enabling this will run tests outside of a try-catch block. Makes debugging &quot; +
			&quot;exceptions in IE reasonable. Stored as query-strings.&quot;
	}
);

QUnit.begin( function() {
	var i, option,
		urlConfig = QUnit.config.urlConfig;

	for ( i = 0; i &lt; urlConfig.length; i++ ) {

		// Options can be either strings or objects with nonempty &quot;id&quot; properties
		option = QUnit.config.urlConfig[ i ];
		if ( typeof option !== &quot;string&quot; ) {
			option = option.id;
		}

		if ( QUnit.config[ option ] === undefined ) {
			QUnit.config[ option ] = urlParams[ option ];
		}
	}
} );

function getUrlParams() {
	var i, param, name, value;
	var urlParams = {};
	var params = location.search.slice( 1 ).split( &quot;&amp;&quot; );
	var length = params.length;

	for ( i = 0; i &lt; length; i++ ) {
		if ( params[ i ] ) {
			param = params[ i ].split( &quot;=&quot; );
			name = decodeQueryParam( param[ 0 ] );

			// Allow just a key to turn on a flag, e.g., test.html?noglobals
			value = param.length === 1 ||
				decodeQueryParam( param.slice( 1 ).join( &quot;=&quot; ) ) ;
			if ( urlParams[ name ] ) {
				urlParams[ name ] = [].concat( urlParams[ name ], value );
			} else {
				urlParams[ name ] = value;
			}
		}
	}

	return urlParams;
}

function decodeQueryParam( param ) {
	return decodeURIComponent( param.replace( /\+/g, &quot;%20&quot; ) );
}

// Don&apos;t load the HTML Reporter on non-browser environments
if ( typeof window === &quot;undefined&quot; || !window.document ) {
	return;
}

QUnit.init = function() {
	throw new Error(
		&quot;QUnit.init is removed in QUnit 2.0, use QUnit.test() with assert.async() instead.\n&quot; +
		&quot;Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/&quot;
	);
};

var config = QUnit.config,
	document = window.document,
	collapseNext = false,
	hasOwn = Object.prototype.hasOwnProperty,
	unfilteredUrl = setUrl( { filter: undefined, module: undefined,
		moduleId: undefined, testId: undefined } ),
	defined = {
		sessionStorage: ( function() {
			var x = &quot;qunit-test-string&quot;;
			try {
				sessionStorage.setItem( x, x );
				sessionStorage.removeItem( x );
				return true;
			} catch ( e ) {
				return false;
			}
		}() )
	},
	modulesList = [];

// Escape text for attribute or text content.
function escapeText( s ) {
	if ( !s ) {
		return &quot;&quot;;
	}
	s = s + &quot;&quot;;

	// Both single quotes and double quotes (for attributes)
	return s.replace( /[&apos;&quot;&lt;&gt;&amp;]/g, function( s ) {
		switch ( s ) {
		case &quot;&apos;&quot;:
			return &quot;&amp;#039;&quot;;
		case &quot;\&quot;&quot;:
			return &quot;&amp;quot;&quot;;
		case &quot;&lt;&quot;:
			return &quot;&amp;lt;&quot;;
		case &quot;&gt;&quot;:
			return &quot;&amp;gt;&quot;;
		case &quot;&amp;&quot;:
			return &quot;&amp;amp;&quot;;
		}
	} );
}

function addEvent( elem, type, fn ) {
	elem.addEventListener( type, fn, false );
}

function removeEvent( elem, type, fn ) {
	elem.removeEventListener( type, fn, false );
}

function addEvents( elems, type, fn ) {
	var i = elems.length;
	while ( i-- ) {
		addEvent( elems[ i ], type, fn );
	}
}

function hasClass( elem, name ) {
	return ( &quot; &quot; + elem.className + &quot; &quot; ).indexOf( &quot; &quot; + name + &quot; &quot; ) &gt;= 0;
}

function addClass( elem, name ) {
	if ( !hasClass( elem, name ) ) {
		elem.className += ( elem.className ? &quot; &quot; : &quot;&quot; ) + name;
	}
}

function toggleClass( elem, name, force ) {
	if ( force || typeof force === &quot;undefined&quot; &amp;&amp; !hasClass( elem, name ) ) {
		addClass( elem, name );
	} else {
		removeClass( elem, name );
	}
}

function removeClass( elem, name ) {
	var set = &quot; &quot; + elem.className + &quot; &quot;;

	// Class name may appear multiple times
	while ( set.indexOf( &quot; &quot; + name + &quot; &quot; ) &gt;= 0 ) {
		set = set.replace( &quot; &quot; + name + &quot; &quot;, &quot; &quot; );
	}

	// Trim for prettiness
	elem.className = typeof set.trim === &quot;function&quot; ? set.trim() : set.replace( /^\s+|\s+$/g, &quot;&quot; );
}

function id( name ) {
	return document.getElementById &amp;&amp; document.getElementById( name );
}

function interceptNavigation( ev ) {
	applyUrlParams();

	if ( ev &amp;&amp; ev.preventDefault ) {
		ev.preventDefault();
	}

	return false;
}

function getUrlConfigHtml() {
	var i, j, val,
		escaped, escapedTooltip,
		selection = false,
		urlConfig = config.urlConfig,
		urlConfigHtml = &quot;&quot;;

	for ( i = 0; i &lt; urlConfig.length; i++ ) {

		// Options can be either strings or objects with nonempty &quot;id&quot; properties
		val = config.urlConfig[ i ];
		if ( typeof val === &quot;string&quot; ) {
			val = {
				id: val,
				label: val
			};
		}

		escaped = escapeText( val.id );
		escapedTooltip = escapeText( val.tooltip );

		if ( !val.value || typeof val.value === &quot;string&quot; ) {
			urlConfigHtml += &quot;&lt;label for=&apos;qunit-urlconfig-&quot; + escaped +
				&quot;&apos; title=&apos;&quot; + escapedTooltip + &quot;&apos;&gt;&lt;input id=&apos;qunit-urlconfig-&quot; + escaped +
				&quot;&apos; name=&apos;&quot; + escaped + &quot;&apos; type=&apos;checkbox&apos;&quot; +
				( val.value ? &quot; value=&apos;&quot; + escapeText( val.value ) + &quot;&apos;&quot; : &quot;&quot; ) +
				( config[ val.id ] ? &quot; checked=&apos;checked&apos;&quot; : &quot;&quot; ) +
				&quot; title=&apos;&quot; + escapedTooltip + &quot;&apos; /&gt;&quot; + escapeText( val.label ) + &quot;&lt;/label&gt;&quot;;
		} else {
			urlConfigHtml += &quot;&lt;label for=&apos;qunit-urlconfig-&quot; + escaped +
				&quot;&apos; title=&apos;&quot; + escapedTooltip + &quot;&apos;&gt;&quot; + val.label +
				&quot;: &lt;/label&gt;&lt;select id=&apos;qunit-urlconfig-&quot; + escaped +
				&quot;&apos; name=&apos;&quot; + escaped + &quot;&apos; title=&apos;&quot; + escapedTooltip + &quot;&apos;&gt;&lt;option&gt;&lt;/option&gt;&quot;;

			if ( QUnit.is( &quot;array&quot;, val.value ) ) {
				for ( j = 0; j &lt; val.value.length; j++ ) {
					escaped = escapeText( val.value[ j ] );
					urlConfigHtml += &quot;&lt;option value=&apos;&quot; + escaped + &quot;&apos;&quot; +
						( config[ val.id ] === val.value[ j ] ?
							( selection = true ) &amp;&amp; &quot; selected=&apos;selected&apos;&quot; : &quot;&quot; ) +
						&quot;&gt;&quot; + escaped + &quot;&lt;/option&gt;&quot;;
				}
			} else {
				for ( j in val.value ) {
					if ( hasOwn.call( val.value, j ) ) {
						urlConfigHtml += &quot;&lt;option value=&apos;&quot; + escapeText( j ) + &quot;&apos;&quot; +
							( config[ val.id ] === j ?
								( selection = true ) &amp;&amp; &quot; selected=&apos;selected&apos;&quot; : &quot;&quot; ) +
							&quot;&gt;&quot; + escapeText( val.value[ j ] ) + &quot;&lt;/option&gt;&quot;;
					}
				}
			}
			if ( config[ val.id ] &amp;&amp; !selection ) {
				escaped = escapeText( config[ val.id ] );
				urlConfigHtml += &quot;&lt;option value=&apos;&quot; + escaped +
					&quot;&apos; selected=&apos;selected&apos; disabled=&apos;disabled&apos;&gt;&quot; + escaped + &quot;&lt;/option&gt;&quot;;
			}
			urlConfigHtml += &quot;&lt;/select&gt;&quot;;
		}
	}

	return urlConfigHtml;
}

// Handle &quot;click&quot; events on toolbar checkboxes and &quot;change&quot; for select menus.
// Updates the URL with the new state of `config.urlConfig` values.
function toolbarChanged() {
	var updatedUrl, value, tests,
		field = this,
		params = {};

	// Detect if field is a select menu or a checkbox
	if ( &quot;selectedIndex&quot; in field ) {
		value = field.options[ field.selectedIndex ].value || undefined;
	} else {
		value = field.checked ? ( field.defaultValue || true ) : undefined;
	}

	params[ field.name ] = value;
	updatedUrl = setUrl( params );

	// Check if we can apply the change without a page refresh
	if ( &quot;hidepassed&quot; === field.name &amp;&amp; &quot;replaceState&quot; in window.history ) {
		QUnit.urlParams[ field.name ] = value;
		config[ field.name ] = value || false;
		tests = id( &quot;qunit-tests&quot; );
		if ( tests ) {
			toggleClass( tests, &quot;hidepass&quot;, value || false );
		}
		window.history.replaceState( null, &quot;&quot;, updatedUrl );
	} else {
		window.location = updatedUrl;
	}
}

function setUrl( params ) {
	var key, arrValue, i,
		querystring = &quot;?&quot;,
		location = window.location;

	params = QUnit.extend( QUnit.extend( {}, QUnit.urlParams ), params );

	for ( key in params ) {

		// Skip inherited or undefined properties
		if ( hasOwn.call( params, key ) &amp;&amp; params[ key ] !== undefined ) {

			// Output a parameter for each value of this key (but usually just one)
			arrValue = [].concat( params[ key ] );
			for ( i = 0; i &lt; arrValue.length; i++ ) {
				querystring += encodeURIComponent( key );
				if ( arrValue[ i ] !== true ) {
					querystring += &quot;=&quot; + encodeURIComponent( arrValue[ i ] );
				}
				querystring += &quot;&amp;&quot;;
			}
		}
	}
	return location.protocol + &quot;//&quot; + location.host +
		location.pathname + querystring.slice( 0, -1 );
}

function applyUrlParams() {
	var i,
		selectedModules = [],
		modulesList = id( &quot;qunit-modulefilter-dropdown-list&quot; ).getElementsByTagName( &quot;input&quot; ),
		filter = id( &quot;qunit-filter-input&quot; ).value;

	for ( i = 0; i &lt; modulesList.length; i++ )  {
		if ( modulesList[ i ].checked ) {
			selectedModules.push( modulesList[ i ].value );
		}
	}

	window.location = setUrl( {
		filter: ( filter === &quot;&quot; ) ? undefined : filter,
		moduleId: ( selectedModules.length === 0 ) ? undefined : selectedModules,

		// Remove module and testId filter
		module: undefined,
		testId: undefined
	} );
}

function toolbarUrlConfigContainer() {
	var urlConfigContainer = document.createElement( &quot;span&quot; );

	urlConfigContainer.innerHTML = getUrlConfigHtml();
	addClass( urlConfigContainer, &quot;qunit-url-config&quot; );

	addEvents( urlConfigContainer.getElementsByTagName( &quot;input&quot; ), &quot;change&quot;, toolbarChanged );
	addEvents( urlConfigContainer.getElementsByTagName( &quot;select&quot; ), &quot;change&quot;, toolbarChanged );

	return urlConfigContainer;
}

function toolbarLooseFilter() {
	var filter = document.createElement( &quot;form&quot; ),
		label = document.createElement( &quot;label&quot; ),
		input = document.createElement( &quot;input&quot; ),
		button = document.createElement( &quot;button&quot; );

	addClass( filter, &quot;qunit-filter&quot; );

	label.innerHTML = &quot;Filter: &quot;;

	input.type = &quot;text&quot;;
	input.value = config.filter || &quot;&quot;;
	input.name = &quot;filter&quot;;
	input.id = &quot;qunit-filter-input&quot;;

	button.innerHTML = &quot;Go&quot;;

	label.appendChild( input );

	filter.appendChild( label );
	filter.appendChild( document.createTextNode( &quot; &quot; ) );
	filter.appendChild( button );
	addEvent( filter, &quot;submit&quot;, interceptNavigation );

	return filter;
}

function moduleListHtml () {
	var i, checked,
		html = &quot;&quot;;

	for ( i = 0; i &lt; config.modules.length; i++ ) {
		if ( config.modules[ i ].name !== &quot;&quot; ) {
			checked = config.moduleId.indexOf( config.modules[ i ].moduleId ) &gt; -1;
			html += &quot;&lt;li&gt;&lt;label class=&apos;clickable&quot; + ( checked ? &quot; checked&quot; : &quot;&quot; ) +
				&quot;&apos;&gt;&lt;input type=&apos;checkbox&apos; &quot; + &quot;value=&apos;&quot; + config.modules[ i ].moduleId + &quot;&apos;&quot; +
				( checked ? &quot; checked=&apos;checked&apos;&quot; : &quot;&quot; ) + &quot; /&gt;&quot; +
				escapeText( config.modules[ i ].name ) + &quot;&lt;/label&gt;&lt;/li&gt;&quot;;
		}
	}

	return html;
}

function toolbarModuleFilter () {
	var allCheckbox, commit, reset,
		moduleFilter = document.createElement( &quot;form&quot; ),
		label = document.createElement( &quot;label&quot; ),
		moduleSearch = document.createElement( &quot;input&quot; ),
		dropDown = document.createElement( &quot;div&quot; ),
		actions = document.createElement( &quot;span&quot; ),
		dropDownList = document.createElement( &quot;ul&quot; ),
		dirty = false;

	moduleSearch.id = &quot;qunit-modulefilter-search&quot;;
	addEvent( moduleSearch, &quot;input&quot;, searchInput );
	addEvent( moduleSearch, &quot;input&quot;, searchFocus );
	addEvent( moduleSearch, &quot;focus&quot;, searchFocus );
	addEvent( moduleSearch, &quot;click&quot;, searchFocus );

	label.id = &quot;qunit-modulefilter-search-container&quot;;
	label.innerHTML = &quot;Module: &quot;;
	label.appendChild( moduleSearch );

	actions.id = &quot;qunit-modulefilter-actions&quot;;
	actions.innerHTML =
		&quot;&lt;button style=&apos;display:none&apos;&gt;Apply&lt;/button&gt;&quot; +
		&quot;&lt;button type=&apos;reset&apos; style=&apos;display:none&apos;&gt;Reset&lt;/button&gt;&quot; +
		&quot;&lt;label class=&apos;clickable&quot; +
		( config.moduleId.length ? &quot;&quot; : &quot; checked&quot; ) +
		&quot;&apos;&gt;&lt;input type=&apos;checkbox&apos;&quot; + ( config.moduleId.length ? &quot;&quot; : &quot; checked=&apos;checked&apos;&quot; ) +
		&quot;&gt;All modules&lt;/label&gt;&quot;;
	allCheckbox = actions.lastChild.firstChild;
	commit = actions.firstChild;
	reset = commit.nextSibling;
	addEvent( commit, &quot;click&quot;, applyUrlParams );

	dropDownList.id = &quot;qunit-modulefilter-dropdown-list&quot;;
	dropDownList.innerHTML = moduleListHtml();

	dropDown.id = &quot;qunit-modulefilter-dropdown&quot;;
	dropDown.style.display = &quot;none&quot;;
	dropDown.appendChild( actions );
	dropDown.appendChild( dropDownList );
	addEvent( dropDown, &quot;change&quot;, selectionChange );
	selectionChange();

	moduleFilter.id = &quot;qunit-modulefilter&quot;;
	moduleFilter.appendChild( label );
	moduleFilter.appendChild( dropDown ) ;
	addEvent( moduleFilter, &quot;submit&quot;, interceptNavigation );
	addEvent( moduleFilter, &quot;reset&quot;, function() {

		// Let the reset happen, then update styles
		window.setTimeout( selectionChange );
	} );

	// Enables show/hide for the dropdown
	function searchFocus() {
		if ( dropDown.style.display !== &quot;none&quot; ) {
			return;
		}

		dropDown.style.display = &quot;block&quot;;
		addEvent( document, &quot;click&quot;, hideHandler );
		addEvent( document, &quot;keydown&quot;, hideHandler );

		// Hide on Escape keydown or outside-container click
		function hideHandler( e )  {
			var inContainer = moduleFilter.contains( e.target );

			if ( e.keyCode === 27 || !inContainer ) {
				if ( e.keyCode === 27 &amp;&amp; inContainer ) {
					moduleSearch.focus();
				}
				dropDown.style.display = &quot;none&quot;;
				removeEvent( document, &quot;click&quot;, hideHandler );
				removeEvent( document, &quot;keydown&quot;, hideHandler );
				moduleSearch.value = &quot;&quot;;
				searchInput();
			}
		}
	}

	// Processes module search box input
	function searchInput() {
		var i, item,
			searchText = moduleSearch.value.toLowerCase(),
			listItems = dropDownList.children;

		for ( i = 0; i &lt; listItems.length; i++ ) {
			item = listItems[ i ];
			if ( !searchText || item.textContent.toLowerCase().indexOf( searchText ) &gt; -1 ) {
				item.style.display = &quot;&quot;;
			} else {
				item.style.display = &quot;none&quot;;
			}
		}
	}

	// Processes selection changes
	function selectionChange( evt ) {
		var i, item,
			checkbox = evt &amp;&amp; evt.target || allCheckbox,
			modulesList = dropDownList.getElementsByTagName( &quot;input&quot; ),
			selectedNames = [];

		toggleClass( checkbox.parentNode, &quot;checked&quot;, checkbox.checked );

		dirty = false;
		if ( checkbox.checked &amp;&amp; checkbox !== allCheckbox ) {
		   allCheckbox.checked = false;
		   removeClass( allCheckbox.parentNode, &quot;checked&quot; );
		}
		for ( i = 0; i &lt; modulesList.length; i++ )  {
			item = modulesList[ i ];
			if ( !evt ) {
				toggleClass( item.parentNode, &quot;checked&quot;, item.checked );
			} else if ( checkbox === allCheckbox &amp;&amp; checkbox.checked ) {
				item.checked = false;
				removeClass( item.parentNode, &quot;checked&quot; );
			}
			dirty = dirty || ( item.checked !== item.defaultChecked );
			if ( item.checked ) {
				selectedNames.push( item.parentNode.textContent );
			}
		}

		commit.style.display = reset.style.display = dirty ? &quot;&quot; : &quot;none&quot;;
		moduleSearch.placeholder = selectedNames.join( &quot;, &quot; ) || allCheckbox.parentNode.textContent;
		moduleSearch.title = &quot;Type to filter list. Current selection:\n&quot; +
			( selectedNames.join( &quot;\n&quot; ) || allCheckbox.parentNode.textContent );
	}

	return moduleFilter;
}

function appendToolbar() {
	var toolbar = id( &quot;qunit-testrunner-toolbar&quot; );

	if ( toolbar ) {
		toolbar.appendChild( toolbarUrlConfigContainer() );
		toolbar.appendChild( toolbarModuleFilter() );
		toolbar.appendChild( toolbarLooseFilter() );
		toolbar.appendChild( document.createElement( &quot;div&quot; ) ).className = &quot;clearfix&quot;;
	}
}

function appendHeader() {
	var header = id( &quot;qunit-header&quot; );

	if ( header ) {
		header.innerHTML = &quot;&lt;a href=&apos;&quot; + escapeText( unfilteredUrl ) + &quot;&apos;&gt;&quot; + header.innerHTML +
			&quot;&lt;/a&gt; &quot;;
	}
}

function appendBanner() {
	var banner = id( &quot;qunit-banner&quot; );

	if ( banner ) {
		banner.className = &quot;&quot;;
	}
}

function appendTestResults() {
	var tests = id( &quot;qunit-tests&quot; ),
		result = id( &quot;qunit-testresult&quot; );

	if ( result ) {
		result.parentNode.removeChild( result );
	}

	if ( tests ) {
		tests.innerHTML = &quot;&quot;;
		result = document.createElement( &quot;p&quot; );
		result.id = &quot;qunit-testresult&quot;;
		result.className = &quot;result&quot;;
		tests.parentNode.insertBefore( result, tests );
		result.innerHTML = &quot;Running...&lt;br /&gt;&amp;#160;&quot;;
	}
}

function appendFilteredTest() {
	var testId = QUnit.config.testId;
	if ( !testId || testId.length &lt;= 0 ) {
		return &quot;&quot;;
	}
	return &quot;&lt;div id=&apos;qunit-filteredTest&apos;&gt;Rerunning selected tests: &quot; +
		escapeText( testId.join( &quot;, &quot; ) ) +
		&quot; &lt;a id=&apos;qunit-clearFilter&apos; href=&apos;&quot; +
		escapeText( unfilteredUrl ) +
		&quot;&apos;&gt;Run all tests&lt;/a&gt;&lt;/div&gt;&quot;;
}

function appendUserAgent() {
	var userAgent = id( &quot;qunit-userAgent&quot; );

	if ( userAgent ) {
		userAgent.innerHTML = &quot;&quot;;
		userAgent.appendChild(
			document.createTextNode(
				&quot;QUnit &quot; + QUnit.version + &quot;; &quot; + navigator.userAgent
			)
		);
	}
}

function appendInterface() {
	var qunit = id( &quot;qunit&quot; );

	if ( qunit ) {
		qunit.innerHTML =
			&quot;&lt;h1 id=&apos;qunit-header&apos;&gt;&quot; + escapeText( document.title ) + &quot;&lt;/h1&gt;&quot; +
			&quot;&lt;h2 id=&apos;qunit-banner&apos;&gt;&lt;/h2&gt;&quot; +
			&quot;&lt;div id=&apos;qunit-testrunner-toolbar&apos;&gt;&lt;/div&gt;&quot; +
			appendFilteredTest() +
			&quot;&lt;h2 id=&apos;qunit-userAgent&apos;&gt;&lt;/h2&gt;&quot; +
			&quot;&lt;ol id=&apos;qunit-tests&apos;&gt;&lt;/ol&gt;&quot;;
	}

	appendHeader();
	appendBanner();
	appendTestResults();
	appendUserAgent();
	appendToolbar();
}

function appendTestsList( modules ) {
	var i, l, x, z, test, moduleObj;

	for ( i = 0, l = modules.length; i &lt; l; i++ ) {
		moduleObj = modules[ i ];

		for ( x = 0, z = moduleObj.tests.length; x &lt; z; x++ ) {
			test = moduleObj.tests[ x ];

			appendTest( test.name, test.testId, moduleObj.name );
		}
	}
}

function appendTest( name, testId, moduleName ) {
	var title, rerunTrigger, testBlock, assertList,
		tests = id( &quot;qunit-tests&quot; );

	if ( !tests ) {
		return;
	}

	title = document.createElement( &quot;strong&quot; );
	title.innerHTML = getNameHtml( name, moduleName );

	rerunTrigger = document.createElement( &quot;a&quot; );
	rerunTrigger.innerHTML = &quot;Rerun&quot;;
	rerunTrigger.href = setUrl( { testId: testId } );

	testBlock = document.createElement( &quot;li&quot; );
	testBlock.appendChild( title );
	testBlock.appendChild( rerunTrigger );
	testBlock.id = &quot;qunit-test-output-&quot; + testId;

	assertList = document.createElement( &quot;ol&quot; );
	assertList.className = &quot;qunit-assert-list&quot;;

	testBlock.appendChild( assertList );

	tests.appendChild( testBlock );
}

// HTML Reporter initialization and load
QUnit.begin( function( details ) {
	var i, moduleObj, tests;

	// Sort modules by name for the picker
	for ( i = 0; i &lt; details.modules.length; i++ ) {
		moduleObj = details.modules[ i ];
		if ( moduleObj.name ) {
			modulesList.push( moduleObj.name );
		}
	}
	modulesList.sort( function( a, b ) {
		return a.localeCompare( b );
	} );

	// Initialize QUnit elements
	appendInterface();
	appendTestsList( details.modules );
	tests = id( &quot;qunit-tests&quot; );
	if ( tests &amp;&amp; config.hidepassed ) {
		addClass( tests, &quot;hidepass&quot; );
	}
} );

QUnit.done( function( details ) {
	var i, key,
		banner = id( &quot;qunit-banner&quot; ),
		tests = id( &quot;qunit-tests&quot; ),
		html = [
			&quot;Tests completed in &quot;,
			details.runtime,
			&quot; milliseconds.&lt;br /&gt;&quot;,
			&quot;&lt;span class=&apos;passed&apos;&gt;&quot;,
			details.passed,
			&quot;&lt;/span&gt; assertions of &lt;span class=&apos;total&apos;&gt;&quot;,
			details.total,
			&quot;&lt;/span&gt; passed, &lt;span class=&apos;failed&apos;&gt;&quot;,
			details.failed,
			&quot;&lt;/span&gt; failed.&quot;
		].join( &quot;&quot; );

	if ( banner ) {
		banner.className = details.failed ? &quot;qunit-fail&quot; : &quot;qunit-pass&quot;;
	}

	if ( tests ) {
		id( &quot;qunit-testresult&quot; ).innerHTML = html;
	}

	if ( config.altertitle &amp;&amp; document.title ) {

		// Show &#x2716; for good, &#x2714; for bad suite result in title
		// use escape sequences in case file gets loaded with non-utf-8-charset
		document.title = [
			( details.failed ? &quot;\u2716&quot; : &quot;\u2714&quot; ),
			document.title.replace( /^[\u2714\u2716] /i, &quot;&quot; )
		].join( &quot; &quot; );
	}

	// Clear own sessionStorage items if all tests passed
	if ( config.reorder &amp;&amp; defined.sessionStorage &amp;&amp; details.failed === 0 ) {
		for ( i = 0; i &lt; sessionStorage.length; i++ ) {
			key = sessionStorage.key( i++ );
			if ( key.indexOf( &quot;qunit-test-&quot; ) === 0 ) {
				sessionStorage.removeItem( key );
			}
		}
	}

	// Scroll back to top to show results
	if ( config.scrolltop &amp;&amp; window.scrollTo ) {
		window.scrollTo( 0, 0 );
	}
} );

function getNameHtml( name, module ) {
	var nameHtml = &quot;&quot;;

	if ( module ) {
		nameHtml = &quot;&lt;span class=&apos;module-name&apos;&gt;&quot; + escapeText( module ) + &quot;&lt;/span&gt;: &quot;;
	}

	nameHtml += &quot;&lt;span class=&apos;test-name&apos;&gt;&quot; + escapeText( name ) + &quot;&lt;/span&gt;&quot;;

	return nameHtml;
}

QUnit.testStart( function( details ) {
	var running, testBlock, bad;

	testBlock = id( &quot;qunit-test-output-&quot; + details.testId );
	if ( testBlock ) {
		testBlock.className = &quot;running&quot;;
	} else {

		// Report later registered tests
		appendTest( details.name, details.testId, details.module );
	}

	running = id( &quot;qunit-testresult&quot; );
	if ( running ) {
		bad = QUnit.config.reorder &amp;&amp; defined.sessionStorage &amp;&amp;
			+sessionStorage.getItem( &quot;qunit-test-&quot; + details.module + &quot;-&quot; + details.name );

		running.innerHTML = ( bad ?
			&quot;Rerunning previously failed test: &lt;br /&gt;&quot; :
			&quot;Running: &lt;br /&gt;&quot; ) +
			getNameHtml( details.name, details.module );
	}

} );

function stripHtml( string ) {

	// Strip tags, html entity and whitespaces
	return string.replace( /&lt;\/?[^&gt;]+(&gt;|$)/g, &quot;&quot; ).replace( /\&amp;quot;/g, &quot;&quot; ).replace( /\s+/g, &quot;&quot; );
}

QUnit.log( function( details ) {
	var assertList, assertLi,
		message, expected, actual, diff,
		showDiff = false,
		testItem = id( &quot;qunit-test-output-&quot; + details.testId );

	if ( !testItem ) {
		return;
	}

	message = escapeText( details.message ) || ( details.result ? &quot;okay&quot; : &quot;failed&quot; );
	message = &quot;&lt;span class=&apos;test-message&apos;&gt;&quot; + message + &quot;&lt;/span&gt;&quot;;
	message += &quot;&lt;span class=&apos;runtime&apos;&gt;@ &quot; + details.runtime + &quot; ms&lt;/span&gt;&quot;;

	// The pushFailure doesn&apos;t provide details.expected
	// when it calls, it&apos;s implicit to also not show expected and diff stuff
	// Also, we need to check details.expected existence, as it can exist and be undefined
	if ( !details.result &amp;&amp; hasOwn.call( details, &quot;expected&quot; ) ) {
		if ( details.negative ) {
			expected = &quot;NOT &quot; + QUnit.dump.parse( details.expected );
		} else {
			expected = QUnit.dump.parse( details.expected );
		}

		actual = QUnit.dump.parse( details.actual );
		message += &quot;&lt;table&gt;&lt;tr class=&apos;test-expected&apos;&gt;&lt;th&gt;Expected: &lt;/th&gt;&lt;td&gt;&lt;pre&gt;&quot; +
			escapeText( expected ) +
			&quot;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&quot;;

		if ( actual !== expected ) {

			message += &quot;&lt;tr class=&apos;test-actual&apos;&gt;&lt;th&gt;Result: &lt;/th&gt;&lt;td&gt;&lt;pre&gt;&quot; +
				escapeText( actual ) + &quot;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&quot;;

			// Don&apos;t show diff if actual or expected are booleans
			if ( !( /^(true|false)$/.test( actual ) ) &amp;&amp;
					!( /^(true|false)$/.test( expected ) ) ) {
				diff = QUnit.diff( expected, actual );
				showDiff = stripHtml( diff ).length !==
					stripHtml( expected ).length +
					stripHtml( actual ).length;
			}

			// Don&apos;t show diff if expected and actual are totally different
			if ( showDiff ) {
				message += &quot;&lt;tr class=&apos;test-diff&apos;&gt;&lt;th&gt;Diff: &lt;/th&gt;&lt;td&gt;&lt;pre&gt;&quot; +
					diff + &quot;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&quot;;
			}
		} else if ( expected.indexOf( &quot;[object Array]&quot; ) !== -1 ||
				expected.indexOf( &quot;[object Object]&quot; ) !== -1 ) {
			message += &quot;&lt;tr class=&apos;test-message&apos;&gt;&lt;th&gt;Message: &lt;/th&gt;&lt;td&gt;&quot; +
				&quot;Diff suppressed as the depth of object is more than current max depth (&quot; +
				QUnit.config.maxDepth + &quot;).&lt;p&gt;Hint: Use &lt;code&gt;QUnit.dump.maxDepth&lt;/code&gt; to &quot; +
				&quot; run with a higher max depth or &lt;a href=&apos;&quot; +
				escapeText( setUrl( { maxDepth: -1 } ) ) + &quot;&apos;&gt;&quot; +
				&quot;Rerun&lt;/a&gt; without max depth.&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&quot;;
		} else {
			message += &quot;&lt;tr class=&apos;test-message&apos;&gt;&lt;th&gt;Message: &lt;/th&gt;&lt;td&gt;&quot; +
				&quot;Diff suppressed as the expected and actual results have an equivalent&quot; +
				&quot; serialization&lt;/td&gt;&lt;/tr&gt;&quot;;
		}

		if ( details.source ) {
			message += &quot;&lt;tr class=&apos;test-source&apos;&gt;&lt;th&gt;Source: &lt;/th&gt;&lt;td&gt;&lt;pre&gt;&quot; +
				escapeText( details.source ) + &quot;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&quot;;
		}

		message += &quot;&lt;/table&gt;&quot;;

	// This occurs when pushFailure is set and we have an extracted stack trace
	} else if ( !details.result &amp;&amp; details.source ) {
		message += &quot;&lt;table&gt;&quot; +
			&quot;&lt;tr class=&apos;test-source&apos;&gt;&lt;th&gt;Source: &lt;/th&gt;&lt;td&gt;&lt;pre&gt;&quot; +
			escapeText( details.source ) + &quot;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&quot; +
			&quot;&lt;/table&gt;&quot;;
	}

	assertList = testItem.getElementsByTagName( &quot;ol&quot; )[ 0 ];

	assertLi = document.createElement( &quot;li&quot; );
	assertLi.className = details.result ? &quot;pass&quot; : &quot;fail&quot;;
	assertLi.innerHTML = message;
	assertList.appendChild( assertLi );
} );

QUnit.testDone( function( details ) {
	var testTitle, time, testItem, assertList,
		good, bad, testCounts, skipped, sourceName,
		tests = id( &quot;qunit-tests&quot; );

	if ( !tests ) {
		return;
	}

	testItem = id( &quot;qunit-test-output-&quot; + details.testId );

	assertList = testItem.getElementsByTagName( &quot;ol&quot; )[ 0 ];

	good = details.passed;
	bad = details.failed;

	// Store result when possible
	if ( config.reorder &amp;&amp; defined.sessionStorage ) {
		if ( bad ) {
			sessionStorage.setItem( &quot;qunit-test-&quot; + details.module + &quot;-&quot; + details.name, bad );
		} else {
			sessionStorage.removeItem( &quot;qunit-test-&quot; + details.module + &quot;-&quot; + details.name );
		}
	}

	if ( bad === 0 ) {

		// Collapse the passing tests
		addClass( assertList, &quot;qunit-collapsed&quot; );
	} else if ( bad &amp;&amp; config.collapse &amp;&amp; !collapseNext ) {

		// Skip collapsing the first failing test
		collapseNext = true;
	} else {

		// Collapse remaining tests
		addClass( assertList, &quot;qunit-collapsed&quot; );
	}

	// The testItem.firstChild is the test name
	testTitle = testItem.firstChild;

	testCounts = bad ?
		&quot;&lt;b class=&apos;failed&apos;&gt;&quot; + bad + &quot;&lt;/b&gt;, &quot; + &quot;&lt;b class=&apos;passed&apos;&gt;&quot; + good + &quot;&lt;/b&gt;, &quot; :
		&quot;&quot;;

	testTitle.innerHTML += &quot; &lt;b class=&apos;counts&apos;&gt;(&quot; + testCounts +
		details.assertions.length + &quot;)&lt;/b&gt;&quot;;

	if ( details.skipped ) {
		testItem.className = &quot;skipped&quot;;
		skipped = document.createElement( &quot;em&quot; );
		skipped.className = &quot;qunit-skipped-label&quot;;
		skipped.innerHTML = &quot;skipped&quot;;
		testItem.insertBefore( skipped, testTitle );
	} else {
		addEvent( testTitle, &quot;click&quot;, function() {
			toggleClass( assertList, &quot;qunit-collapsed&quot; );
		} );

		testItem.className = bad ? &quot;fail&quot; : &quot;pass&quot;;

		time = document.createElement( &quot;span&quot; );
		time.className = &quot;runtime&quot;;
		time.innerHTML = details.runtime + &quot; ms&quot;;
		testItem.insertBefore( time, assertList );
	}

	// Show the source of the test when showing assertions
	if ( details.source ) {
		sourceName = document.createElement( &quot;p&quot; );
		sourceName.innerHTML = &quot;&lt;strong&gt;Source: &lt;/strong&gt;&quot; + details.source;
		addClass( sourceName, &quot;qunit-source&quot; );
		if ( bad === 0 ) {
			addClass( sourceName, &quot;qunit-collapsed&quot; );
		}
		addEvent( testTitle, &quot;click&quot;, function() {
			toggleClass( sourceName, &quot;qunit-collapsed&quot; );
		} );
		testItem.appendChild( sourceName );
	}
} );

// Avoid readyState issue with phantomjs
// Ref: #818
var notPhantom = ( function( p ) {
	return !( p &amp;&amp; p.version &amp;&amp; p.version.major &gt; 0 );
} )( window.phantom );

if ( notPhantom &amp;&amp; document.readyState === &quot;complete&quot; ) {
	QUnit.load();
} else {
	addEvent( window, &quot;load&quot;, QUnit.load );
}

/*
 * This file is a modified version of google-diff-match-patch&apos;s JavaScript implementation
 * (https://code.google.com/p/google-diff-match-patch/source/browse/trunk/javascript/diff_match_patch_uncompressed.js),
 * modifications are licensed as more fully set forth in LICENSE.txt.
 *
 * The original source of google-diff-match-patch is attributable and licensed as follows:
 *
 * Copyright 2006 Google Inc.
 * https://code.google.com/p/google-diff-match-patch/
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * More Info:
 *  https://code.google.com/p/google-diff-match-patch/
 *
 * Usage: QUnit.diff(expected, actual)
 *
 */
QUnit.diff = ( function() {
	function DiffMatchPatch() {
	}

	//  DIFF FUNCTIONS

	/**
	 * The data structure representing a diff is an array of tuples:
	 * [[DIFF_DELETE, &apos;Hello&apos;], [DIFF_INSERT, &apos;Goodbye&apos;], [DIFF_EQUAL, &apos; world.&apos;]]
	 * which means: delete &apos;Hello&apos;, add &apos;Goodbye&apos; and keep &apos; world.&apos;
	 */
	var DIFF_DELETE = -1,
		DIFF_INSERT = 1,
		DIFF_EQUAL = 0;

	/**
	 * Find the differences between two texts.  Simplifies the problem by stripping
	 * any common prefix or suffix off the texts before diffing.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @param {boolean=} optChecklines Optional speedup flag. If present and false,
	 *     then don&apos;t run a line-level diff first to identify the changed areas.
	 *     Defaults to true, which does a faster, slightly less optimal diff.
	 * @return {!Array.&lt;!DiffMatchPatch.Diff&gt;} Array of diff tuples.
	 */
	DiffMatchPatch.prototype.DiffMain = function( text1, text2, optChecklines ) {
		var deadline, checklines, commonlength,
			commonprefix, commonsuffix, diffs;

		// The diff must be complete in up to 1 second.
		deadline = ( new Date() ).getTime() + 1000;

		// Check for null inputs.
		if ( text1 === null || text2 === null ) {
			throw new Error( &quot;Null input. (DiffMain)&quot; );
		}

		// Check for equality (speedup).
		if ( text1 === text2 ) {
			if ( text1 ) {
				return [
					[ DIFF_EQUAL, text1 ]
				];
			}
			return [];
		}

		if ( typeof optChecklines === &quot;undefined&quot; ) {
			optChecklines = true;
		}

		checklines = optChecklines;

		// Trim off common prefix (speedup).
		commonlength = this.diffCommonPrefix( text1, text2 );
		commonprefix = text1.substring( 0, commonlength );
		text1 = text1.substring( commonlength );
		text2 = text2.substring( commonlength );

		// Trim off common suffix (speedup).
		commonlength = this.diffCommonSuffix( text1, text2 );
		commonsuffix = text1.substring( text1.length - commonlength );
		text1 = text1.substring( 0, text1.length - commonlength );
		text2 = text2.substring( 0, text2.length - commonlength );

		// Compute the diff on the middle block.
		diffs = this.diffCompute( text1, text2, checklines, deadline );

		// Restore the prefix and suffix.
		if ( commonprefix ) {
			diffs.unshift( [ DIFF_EQUAL, commonprefix ] );
		}
		if ( commonsuffix ) {
			diffs.push( [ DIFF_EQUAL, commonsuffix ] );
		}
		this.diffCleanupMerge( diffs );
		return diffs;
	};

	/**
	 * Reduce the number of edits by eliminating operationally trivial equalities.
	 * @param {!Array.&lt;!DiffMatchPatch.Diff&gt;} diffs Array of diff tuples.
	 */
	DiffMatchPatch.prototype.diffCleanupEfficiency = function( diffs ) {
		var changes, equalities, equalitiesLength, lastequality,
			pointer, preIns, preDel, postIns, postDel;
		changes = false;
		equalities = []; // Stack of indices where equalities are found.
		equalitiesLength = 0; // Keeping our own length var is faster in JS.
		/** @type {?string} */
		lastequality = null;

		// Always equal to diffs[equalities[equalitiesLength - 1]][1]
		pointer = 0; // Index of current position.

		// Is there an insertion operation before the last equality.
		preIns = false;

		// Is there a deletion operation before the last equality.
		preDel = false;

		// Is there an insertion operation after the last equality.
		postIns = false;

		// Is there a deletion operation after the last equality.
		postDel = false;
		while ( pointer &lt; diffs.length ) {

			// Equality found.
			if ( diffs[ pointer ][ 0 ] === DIFF_EQUAL ) {
				if ( diffs[ pointer ][ 1 ].length &lt; 4 &amp;&amp; ( postIns || postDel ) ) {

					// Candidate found.
					equalities[ equalitiesLength++ ] = pointer;
					preIns = postIns;
					preDel = postDel;
					lastequality = diffs[ pointer ][ 1 ];
				} else {

					// Not a candidate, and can never become one.
					equalitiesLength = 0;
					lastequality = null;
				}
				postIns = postDel = false;

			// An insertion or deletion.
			} else {

				if ( diffs[ pointer ][ 0 ] === DIFF_DELETE ) {
					postDel = true;
				} else {
					postIns = true;
				}

				/*
				 * Five types to be split:
				 * &lt;ins&gt;A&lt;/ins&gt;&lt;del&gt;B&lt;/del&gt;XY&lt;ins&gt;C&lt;/ins&gt;&lt;del&gt;D&lt;/del&gt;
				 * &lt;ins&gt;A&lt;/ins&gt;X&lt;ins&gt;C&lt;/ins&gt;&lt;del&gt;D&lt;/del&gt;
				 * &lt;ins&gt;A&lt;/ins&gt;&lt;del&gt;B&lt;/del&gt;X&lt;ins&gt;C&lt;/ins&gt;
				 * &lt;ins&gt;A&lt;/del&gt;X&lt;ins&gt;C&lt;/ins&gt;&lt;del&gt;D&lt;/del&gt;
				 * &lt;ins&gt;A&lt;/ins&gt;&lt;del&gt;B&lt;/del&gt;X&lt;del&gt;C&lt;/del&gt;
				 */
				if ( lastequality &amp;&amp; ( ( preIns &amp;&amp; preDel &amp;&amp; postIns &amp;&amp; postDel ) ||
						( ( lastequality.length &lt; 2 ) &amp;&amp;
						( preIns + preDel + postIns + postDel ) === 3 ) ) ) {

					// Duplicate record.
					diffs.splice(
						equalities[ equalitiesLength - 1 ],
						0,
						[ DIFF_DELETE, lastequality ]
					);

					// Change second copy to insert.
					diffs[ equalities[ equalitiesLength - 1 ] + 1 ][ 0 ] = DIFF_INSERT;
					equalitiesLength--; // Throw away the equality we just deleted;
					lastequality = null;
					if ( preIns &amp;&amp; preDel ) {

						// No changes made which could affect previous entry, keep going.
						postIns = postDel = true;
						equalitiesLength = 0;
					} else {
						equalitiesLength--; // Throw away the previous equality.
						pointer = equalitiesLength &gt; 0 ? equalities[ equalitiesLength - 1 ] : -1;
						postIns = postDel = false;
					}
					changes = true;
				}
			}
			pointer++;
		}

		if ( changes ) {
			this.diffCleanupMerge( diffs );
		}
	};

	/**
	 * Convert a diff array into a pretty HTML report.
	 * @param {!Array.&lt;!DiffMatchPatch.Diff&gt;} diffs Array of diff tuples.
	 * @param {integer} string to be beautified.
	 * @return {string} HTML representation.
	 */
	DiffMatchPatch.prototype.diffPrettyHtml = function( diffs ) {
		var op, data, x,
			html = [];
		for ( x = 0; x &lt; diffs.length; x++ ) {
			op = diffs[ x ][ 0 ]; // Operation (insert, delete, equal)
			data = diffs[ x ][ 1 ]; // Text of change.
			switch ( op ) {
			case DIFF_INSERT:
				html[ x ] = &quot;&lt;ins&gt;&quot; + escapeText( data ) + &quot;&lt;/ins&gt;&quot;;
				break;
			case DIFF_DELETE:
				html[ x ] = &quot;&lt;del&gt;&quot; + escapeText( data ) + &quot;&lt;/del&gt;&quot;;
				break;
			case DIFF_EQUAL:
				html[ x ] = &quot;&lt;span&gt;&quot; + escapeText( data ) + &quot;&lt;/span&gt;&quot;;
				break;
			}
		}
		return html.join( &quot;&quot; );
	};

	/**
	 * Determine the common prefix of two strings.
	 * @param {string} text1 First string.
	 * @param {string} text2 Second string.
	 * @return {number} The number of characters common to the start of each
	 *     string.
	 */
	DiffMatchPatch.prototype.diffCommonPrefix = function( text1, text2 ) {
		var pointermid, pointermax, pointermin, pointerstart;

		// Quick check for common null cases.
		if ( !text1 || !text2 || text1.charAt( 0 ) !== text2.charAt( 0 ) ) {
			return 0;
		}

		// Binary search.
		// Performance analysis: https://neil.fraser.name/news/2007/10/09/
		pointermin = 0;
		pointermax = Math.min( text1.length, text2.length );
		pointermid = pointermax;
		pointerstart = 0;
		while ( pointermin &lt; pointermid ) {
			if ( text1.substring( pointerstart, pointermid ) ===
					text2.substring( pointerstart, pointermid ) ) {
				pointermin = pointermid;
				pointerstart = pointermin;
			} else {
				pointermax = pointermid;
			}
			pointermid = Math.floor( ( pointermax - pointermin ) / 2 + pointermin );
		}
		return pointermid;
	};

	/**
	 * Determine the common suffix of two strings.
	 * @param {string} text1 First string.
	 * @param {string} text2 Second string.
	 * @return {number} The number of characters common to the end of each string.
	 */
	DiffMatchPatch.prototype.diffCommonSuffix = function( text1, text2 ) {
		var pointermid, pointermax, pointermin, pointerend;

		// Quick check for common null cases.
		if ( !text1 ||
				!text2 ||
				text1.charAt( text1.length - 1 ) !== text2.charAt( text2.length - 1 ) ) {
			return 0;
		}

		// Binary search.
		// Performance analysis: https://neil.fraser.name/news/2007/10/09/
		pointermin = 0;
		pointermax = Math.min( text1.length, text2.length );
		pointermid = pointermax;
		pointerend = 0;
		while ( pointermin &lt; pointermid ) {
			if ( text1.substring( text1.length - pointermid, text1.length - pointerend ) ===
					text2.substring( text2.length - pointermid, text2.length - pointerend ) ) {
				pointermin = pointermid;
				pointerend = pointermin;
			} else {
				pointermax = pointermid;
			}
			pointermid = Math.floor( ( pointermax - pointermin ) / 2 + pointermin );
		}
		return pointermid;
	};

	/**
	 * Find the differences between two texts.  Assumes that the texts do not
	 * have any common prefix or suffix.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @param {boolean} checklines Speedup flag.  If false, then don&apos;t run a
	 *     line-level diff first to identify the changed areas.
	 *     If true, then run a faster, slightly less optimal diff.
	 * @param {number} deadline Time when the diff should be complete by.
	 * @return {!Array.&lt;!DiffMatchPatch.Diff&gt;} Array of diff tuples.
	 * @private
	 */
	DiffMatchPatch.prototype.diffCompute = function( text1, text2, checklines, deadline ) {
		var diffs, longtext, shorttext, i, hm,
			text1A, text2A, text1B, text2B,
			midCommon, diffsA, diffsB;

		if ( !text1 ) {

			// Just add some text (speedup).
			return [
				[ DIFF_INSERT, text2 ]
			];
		}

		if ( !text2 ) {

			// Just delete some text (speedup).
			return [
				[ DIFF_DELETE, text1 ]
			];
		}

		longtext = text1.length &gt; text2.length ? text1 : text2;
		shorttext = text1.length &gt; text2.length ? text2 : text1;
		i = longtext.indexOf( shorttext );
		if ( i !== -1 ) {

			// Shorter text is inside the longer text (speedup).
			diffs = [
				[ DIFF_INSERT, longtext.substring( 0, i ) ],
				[ DIFF_EQUAL, shorttext ],
				[ DIFF_INSERT, longtext.substring( i + shorttext.length ) ]
			];

			// Swap insertions for deletions if diff is reversed.
			if ( text1.length &gt; text2.length ) {
				diffs[ 0 ][ 0 ] = diffs[ 2 ][ 0 ] = DIFF_DELETE;
			}
			return diffs;
		}

		if ( shorttext.length === 1 ) {

			// Single character string.
			// After the previous speedup, the character can&apos;t be an equality.
			return [
				[ DIFF_DELETE, text1 ],
				[ DIFF_INSERT, text2 ]
			];
		}

		// Check to see if the problem can be split in two.
		hm = this.diffHalfMatch( text1, text2 );
		if ( hm ) {

			// A half-match was found, sort out the return data.
			text1A = hm[ 0 ];
			text1B = hm[ 1 ];
			text2A = hm[ 2 ];
			text2B = hm[ 3 ];
			midCommon = hm[ 4 ];

			// Send both pairs off for separate processing.
			diffsA = this.DiffMain( text1A, text2A, checklines, deadline );
			diffsB = this.DiffMain( text1B, text2B, checklines, deadline );

			// Merge the results.
			return diffsA.concat( [
				[ DIFF_EQUAL, midCommon ]
			], diffsB );
		}

		if ( checklines &amp;&amp; text1.length &gt; 100 &amp;&amp; text2.length &gt; 100 ) {
			return this.diffLineMode( text1, text2, deadline );
		}

		return this.diffBisect( text1, text2, deadline );
	};

	/**
	 * Do the two texts share a substring which is at least half the length of the
	 * longer text?
	 * This speedup can produce non-minimal diffs.
	 * @param {string} text1 First string.
	 * @param {string} text2 Second string.
	 * @return {Array.&lt;string&gt;} Five element Array, containing the prefix of
	 *     text1, the suffix of text1, the prefix of text2, the suffix of
	 *     text2 and the common middle.  Or null if there was no match.
	 * @private
	 */
	DiffMatchPatch.prototype.diffHalfMatch = function( text1, text2 ) {
		var longtext, shorttext, dmp,
			text1A, text2B, text2A, text1B, midCommon,
			hm1, hm2, hm;

		longtext = text1.length &gt; text2.length ? text1 : text2;
		shorttext = text1.length &gt; text2.length ? text2 : text1;
		if ( longtext.length &lt; 4 || shorttext.length * 2 &lt; longtext.length ) {
			return null; // Pointless.
		}
		dmp = this; // &apos;this&apos; becomes &apos;window&apos; in a closure.

		/**
		 * Does a substring of shorttext exist within longtext such that the substring
		 * is at least half the length of longtext?
		 * Closure, but does not reference any external variables.
		 * @param {string} longtext Longer string.
		 * @param {string} shorttext Shorter string.
		 * @param {number} i Start index of quarter length substring within longtext.
		 * @return {Array.&lt;string&gt;} Five element Array, containing the prefix of
		 *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
		 *     of shorttext and the common middle.  Or null if there was no match.
		 * @private
		 */
		function diffHalfMatchI( longtext, shorttext, i ) {
			var seed, j, bestCommon, prefixLength, suffixLength,
				bestLongtextA, bestLongtextB, bestShorttextA, bestShorttextB;

			// Start with a 1/4 length substring at position i as a seed.
			seed = longtext.substring( i, i + Math.floor( longtext.length / 4 ) );
			j = -1;
			bestCommon = &quot;&quot;;
			while ( ( j = shorttext.indexOf( seed, j + 1 ) ) !== -1 ) {
				prefixLength = dmp.diffCommonPrefix( longtext.substring( i ),
					shorttext.substring( j ) );
				suffixLength = dmp.diffCommonSuffix( longtext.substring( 0, i ),
					shorttext.substring( 0, j ) );
				if ( bestCommon.length &lt; suffixLength + prefixLength ) {
					bestCommon = shorttext.substring( j - suffixLength, j ) +
						shorttext.substring( j, j + prefixLength );
					bestLongtextA = longtext.substring( 0, i - suffixLength );
					bestLongtextB = longtext.substring( i + prefixLength );
					bestShorttextA = shorttext.substring( 0, j - suffixLength );
					bestShorttextB = shorttext.substring( j + prefixLength );
				}
			}
			if ( bestCommon.length * 2 &gt;= longtext.length ) {
				return [ bestLongtextA, bestLongtextB,
					bestShorttextA, bestShorttextB, bestCommon
				];
			} else {
				return null;
			}
		}

		// First check if the second quarter is the seed for a half-match.
		hm1 = diffHalfMatchI( longtext, shorttext,
			Math.ceil( longtext.length / 4 ) );

		// Check again based on the third quarter.
		hm2 = diffHalfMatchI( longtext, shorttext,
			Math.ceil( longtext.length / 2 ) );
		if ( !hm1 &amp;&amp; !hm2 ) {
			return null;
		} else if ( !hm2 ) {
			hm = hm1;
		} else if ( !hm1 ) {
			hm = hm2;
		} else {

			// Both matched.  Select the longest.
			hm = hm1[ 4 ].length &gt; hm2[ 4 ].length ? hm1 : hm2;
		}

		// A half-match was found, sort out the return data.
		text1A, text1B, text2A, text2B;
		if ( text1.length &gt; text2.length ) {
			text1A = hm[ 0 ];
			text1B = hm[ 1 ];
			text2A = hm[ 2 ];
			text2B = hm[ 3 ];
		} else {
			text2A = hm[ 0 ];
			text2B = hm[ 1 ];
			text1A = hm[ 2 ];
			text1B = hm[ 3 ];
		}
		midCommon = hm[ 4 ];
		return [ text1A, text1B, text2A, text2B, midCommon ];
	};

	/**
	 * Do a quick line-level diff on both strings, then rediff the parts for
	 * greater accuracy.
	 * This speedup can produce non-minimal diffs.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @param {number} deadline Time when the diff should be complete by.
	 * @return {!Array.&lt;!DiffMatchPatch.Diff&gt;} Array of diff tuples.
	 * @private
	 */
	DiffMatchPatch.prototype.diffLineMode = function( text1, text2, deadline ) {
		var a, diffs, linearray, pointer, countInsert,
			countDelete, textInsert, textDelete, j;

		// Scan the text on a line-by-line basis first.
		a = this.diffLinesToChars( text1, text2 );
		text1 = a.chars1;
		text2 = a.chars2;
		linearray = a.lineArray;

		diffs = this.DiffMain( text1, text2, false, deadline );

		// Convert the diff back to original text.
		this.diffCharsToLines( diffs, linearray );

		// Eliminate freak matches (e.g. blank lines)
		this.diffCleanupSemantic( diffs );

		// Rediff any replacement blocks, this time character-by-character.
		// Add a dummy entry at the end.
		diffs.push( [ DIFF_EQUAL, &quot;&quot; ] );
		pointer = 0;
		countDelete = 0;
		countInsert = 0;
		textDelete = &quot;&quot;;
		textInsert = &quot;&quot;;
		while ( pointer &lt; diffs.length ) {
			switch ( diffs[ pointer ][ 0 ] ) {
			case DIFF_INSERT:
				countInsert++;
				textInsert += diffs[ pointer ][ 1 ];
				break;
			case DIFF_DELETE:
				countDelete++;
				textDelete += diffs[ pointer ][ 1 ];
				break;
			case DIFF_EQUAL:

				// Upon reaching an equality, check for prior redundancies.
				if ( countDelete &gt;= 1 &amp;&amp; countInsert &gt;= 1 ) {

					// Delete the offending records and add the merged ones.
					diffs.splice( pointer - countDelete - countInsert,
						countDelete + countInsert );
					pointer = pointer - countDelete - countInsert;
					a = this.DiffMain( textDelete, textInsert, false, deadline );
					for ( j = a.length - 1; j &gt;= 0; j-- ) {
						diffs.splice( pointer, 0, a[ j ] );
					}
					pointer = pointer + a.length;
				}
				countInsert = 0;
				countDelete = 0;
				textDelete = &quot;&quot;;
				textInsert = &quot;&quot;;
				break;
			}
			pointer++;
		}
		diffs.pop(); // Remove the dummy entry at the end.

		return diffs;
	};

	/**
	 * Find the &apos;middle snake&apos; of a diff, split the problem in two
	 * and return the recursively constructed diff.
	 * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @param {number} deadline Time at which to bail if not yet complete.
	 * @return {!Array.&lt;!DiffMatchPatch.Diff&gt;} Array of diff tuples.
	 * @private
	 */
	DiffMatchPatch.prototype.diffBisect = function( text1, text2, deadline ) {
		var text1Length, text2Length, maxD, vOffset, vLength,
			v1, v2, x, delta, front, k1start, k1end, k2start,
			k2end, k2Offset, k1Offset, x1, x2, y1, y2, d, k1, k2;

		// Cache the text lengths to prevent multiple calls.
		text1Length = text1.length;
		text2Length = text2.length;
		maxD = Math.ceil( ( text1Length + text2Length ) / 2 );
		vOffset = maxD;
		vLength = 2 * maxD;
		v1 = new Array( vLength );
		v2 = new Array( vLength );

		// Setting all elements to -1 is faster in Chrome &amp; Firefox than mixing
		// integers and undefined.
		for ( x = 0; x &lt; vLength; x++ ) {
			v1[ x ] = -1;
			v2[ x ] = -1;
		}
		v1[ vOffset + 1 ] = 0;
		v2[ vOffset + 1 ] = 0;
		delta = text1Length - text2Length;

		// If the total number of characters is odd, then the front path will collide
		// with the reverse path.
		front = ( delta % 2 !== 0 );

		// Offsets for start and end of k loop.
		// Prevents mapping of space beyond the grid.
		k1start = 0;
		k1end = 0;
		k2start = 0;
		k2end = 0;
		for ( d = 0; d &lt; maxD; d++ ) {

			// Bail out if deadline is reached.
			if ( ( new Date() ).getTime() &gt; deadline ) {
				break;
			}

			// Walk the front path one step.
			for ( k1 = -d + k1start; k1 &lt;= d - k1end; k1 += 2 ) {
				k1Offset = vOffset + k1;
				if ( k1 === -d || ( k1 !== d &amp;&amp; v1[ k1Offset - 1 ] &lt; v1[ k1Offset + 1 ] ) ) {
					x1 = v1[ k1Offset + 1 ];
				} else {
					x1 = v1[ k1Offset - 1 ] + 1;
				}
				y1 = x1 - k1;
				while ( x1 &lt; text1Length &amp;&amp; y1 &lt; text2Length &amp;&amp;
					text1.charAt( x1 ) === text2.charAt( y1 ) ) {
					x1++;
					y1++;
				}
				v1[ k1Offset ] = x1;
				if ( x1 &gt; text1Length ) {

					// Ran off the right of the graph.
					k1end += 2;
				} else if ( y1 &gt; text2Length ) {

					// Ran off the bottom of the graph.
					k1start += 2;
				} else if ( front ) {
					k2Offset = vOffset + delta - k1;
					if ( k2Offset &gt;= 0 &amp;&amp; k2Offset &lt; vLength &amp;&amp; v2[ k2Offset ] !== -1 ) {

						// Mirror x2 onto top-left coordinate system.
						x2 = text1Length - v2[ k2Offset ];
						if ( x1 &gt;= x2 ) {

							// Overlap detected.
							return this.diffBisectSplit( text1, text2, x1, y1, deadline );
						}
					}
				}
			}

			// Walk the reverse path one step.
			for ( k2 = -d + k2start; k2 &lt;= d - k2end; k2 += 2 ) {
				k2Offset = vOffset + k2;
				if ( k2 === -d || ( k2 !== d &amp;&amp; v2[ k2Offset - 1 ] &lt; v2[ k2Offset + 1 ] ) ) {
					x2 = v2[ k2Offset + 1 ];
				} else {
					x2 = v2[ k2Offset - 1 ] + 1;
				}
				y2 = x2 - k2;
				while ( x2 &lt; text1Length &amp;&amp; y2 &lt; text2Length &amp;&amp;
					text1.charAt( text1Length - x2 - 1 ) ===
					text2.charAt( text2Length - y2 - 1 ) ) {
					x2++;
					y2++;
				}
				v2[ k2Offset ] = x2;
				if ( x2 &gt; text1Length ) {

					// Ran off the left of the graph.
					k2end += 2;
				} else if ( y2 &gt; text2Length ) {

					// Ran off the top of the graph.
					k2start += 2;
				} else if ( !front ) {
					k1Offset = vOffset + delta - k2;
					if ( k1Offset &gt;= 0 &amp;&amp; k1Offset &lt; vLength &amp;&amp; v1[ k1Offset ] !== -1 ) {
						x1 = v1[ k1Offset ];
						y1 = vOffset + x1 - k1Offset;

						// Mirror x2 onto top-left coordinate system.
						x2 = text1Length - x2;
						if ( x1 &gt;= x2 ) {

							// Overlap detected.
							return this.diffBisectSplit( text1, text2, x1, y1, deadline );
						}
					}
				}
			}
		}

		// Diff took too long and hit the deadline or
		// number of diffs equals number of characters, no commonality at all.
		return [
			[ DIFF_DELETE, text1 ],
			[ DIFF_INSERT, text2 ]
		];
	};

	/**
	 * Given the location of the &apos;middle snake&apos;, split the diff in two parts
	 * and recurse.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @param {number} x Index of split point in text1.
	 * @param {number} y Index of split point in text2.
	 * @param {number} deadline Time at which to bail if not yet complete.
	 * @return {!Array.&lt;!DiffMatchPatch.Diff&gt;} Array of diff tuples.
	 * @private
	 */
	DiffMatchPatch.prototype.diffBisectSplit = function( text1, text2, x, y, deadline ) {
		var text1a, text1b, text2a, text2b, diffs, diffsb;
		text1a = text1.substring( 0, x );
		text2a = text2.substring( 0, y );
		text1b = text1.substring( x );
		text2b = text2.substring( y );

		// Compute both diffs serially.
		diffs = this.DiffMain( text1a, text2a, false, deadline );
		diffsb = this.DiffMain( text1b, text2b, false, deadline );

		return diffs.concat( diffsb );
	};

	/**
	 * Reduce the number of edits by eliminating semantically trivial equalities.
	 * @param {!Array.&lt;!DiffMatchPatch.Diff&gt;} diffs Array of diff tuples.
	 */
	DiffMatchPatch.prototype.diffCleanupSemantic = function( diffs ) {
		var changes, equalities, equalitiesLength, lastequality,
			pointer, lengthInsertions2, lengthDeletions2, lengthInsertions1,
			lengthDeletions1, deletion, insertion, overlapLength1, overlapLength2;
		changes = false;
		equalities = []; // Stack of indices where equalities are found.
		equalitiesLength = 0; // Keeping our own length var is faster in JS.
		/** @type {?string} */
		lastequality = null;

		// Always equal to diffs[equalities[equalitiesLength - 1]][1]
		pointer = 0; // Index of current position.

		// Number of characters that changed prior to the equality.
		lengthInsertions1 = 0;
		lengthDeletions1 = 0;

		// Number of characters that changed after the equality.
		lengthInsertions2 = 0;
		lengthDeletions2 = 0;
		while ( pointer &lt; diffs.length ) {
			if ( diffs[ pointer ][ 0 ] === DIFF_EQUAL ) { // Equality found.
				equalities[ equalitiesLength++ ] = pointer;
				lengthInsertions1 = lengthInsertions2;
				lengthDeletions1 = lengthDeletions2;
				lengthInsertions2 = 0;
				lengthDeletions2 = 0;
				lastequality = diffs[ pointer ][ 1 ];
			} else { // An insertion or deletion.
				if ( diffs[ pointer ][ 0 ] === DIFF_INSERT ) {
					lengthInsertions2 += diffs[ pointer ][ 1 ].length;
				} else {
					lengthDeletions2 += diffs[ pointer ][ 1 ].length;
				}

				// Eliminate an equality that is smaller or equal to the edits on both
				// sides of it.
				if ( lastequality &amp;&amp; ( lastequality.length &lt;=
						Math.max( lengthInsertions1, lengthDeletions1 ) ) &amp;&amp;
						( lastequality.length &lt;= Math.max( lengthInsertions2,
							lengthDeletions2 ) ) ) {

					// Duplicate record.
					diffs.splice(
						equalities[ equalitiesLength - 1 ],
						0,
						[ DIFF_DELETE, lastequality ]
					);

					// Change second copy to insert.
					diffs[ equalities[ equalitiesLength - 1 ] + 1 ][ 0 ] = DIFF_INSERT;

					// Throw away the equality we just deleted.
					equalitiesLength--;

					// Throw away the previous equality (it needs to be reevaluated).
					equalitiesLength--;
					pointer = equalitiesLength &gt; 0 ? equalities[ equalitiesLength - 1 ] : -1;

					// Reset the counters.
					lengthInsertions1 = 0;
					lengthDeletions1 = 0;
					lengthInsertions2 = 0;
					lengthDeletions2 = 0;
					lastequality = null;
					changes = true;
				}
			}
			pointer++;
		}

		// Normalize the diff.
		if ( changes ) {
			this.diffCleanupMerge( diffs );
		}

		// Find any overlaps between deletions and insertions.
		// e.g: &lt;del&gt;abcxxx&lt;/del&gt;&lt;ins&gt;xxxdef&lt;/ins&gt;
		//   -&gt; &lt;del&gt;abc&lt;/del&gt;xxx&lt;ins&gt;def&lt;/ins&gt;
		// e.g: &lt;del&gt;xxxabc&lt;/del&gt;&lt;ins&gt;defxxx&lt;/ins&gt;
		//   -&gt; &lt;ins&gt;def&lt;/ins&gt;xxx&lt;del&gt;abc&lt;/del&gt;
		// Only extract an overlap if it is as big as the edit ahead or behind it.
		pointer = 1;
		while ( pointer &lt; diffs.length ) {
			if ( diffs[ pointer - 1 ][ 0 ] === DIFF_DELETE &amp;&amp;
					diffs[ pointer ][ 0 ] === DIFF_INSERT ) {
				deletion = diffs[ pointer - 1 ][ 1 ];
				insertion = diffs[ pointer ][ 1 ];
				overlapLength1 = this.diffCommonOverlap( deletion, insertion );
				overlapLength2 = this.diffCommonOverlap( insertion, deletion );
				if ( overlapLength1 &gt;= overlapLength2 ) {
					if ( overlapLength1 &gt;= deletion.length / 2 ||
							overlapLength1 &gt;= insertion.length / 2 ) {

						// Overlap found.  Insert an equality and trim the surrounding edits.
						diffs.splice(
							pointer,
							0,
							[ DIFF_EQUAL, insertion.substring( 0, overlapLength1 ) ]
						);
						diffs[ pointer - 1 ][ 1 ] =
							deletion.substring( 0, deletion.length - overlapLength1 );
						diffs[ pointer + 1 ][ 1 ] = insertion.substring( overlapLength1 );
						pointer++;
					}
				} else {
					if ( overlapLength2 &gt;= deletion.length / 2 ||
							overlapLength2 &gt;= insertion.length / 2 ) {

						// Reverse overlap found.
						// Insert an equality and swap and trim the surrounding edits.
						diffs.splice(
							pointer,
							0,
							[ DIFF_EQUAL, deletion.substring( 0, overlapLength2 ) ]
						);

						diffs[ pointer - 1 ][ 0 ] = DIFF_INSERT;
						diffs[ pointer - 1 ][ 1 ] =
							insertion.substring( 0, insertion.length - overlapLength2 );
						diffs[ pointer + 1 ][ 0 ] = DIFF_DELETE;
						diffs[ pointer + 1 ][ 1 ] =
							deletion.substring( overlapLength2 );
						pointer++;
					}
				}
				pointer++;
			}
			pointer++;
		}
	};

	/**
	 * Determine if the suffix of one string is the prefix of another.
	 * @param {string} text1 First string.
	 * @param {string} text2 Second string.
	 * @return {number} The number of characters common to the end of the first
	 *     string and the start of the second string.
	 * @private
	 */
	DiffMatchPatch.prototype.diffCommonOverlap = function( text1, text2 ) {
		var text1Length, text2Length, textLength,
			best, length, pattern, found;

		// Cache the text lengths to prevent multiple calls.
		text1Length = text1.length;
		text2Length = text2.length;

		// Eliminate the null case.
		if ( text1Length === 0 || text2Length === 0 ) {
			return 0;
		}

		// Truncate the longer string.
		if ( text1Length &gt; text2Length ) {
			text1 = text1.substring( text1Length - text2Length );
		} else if ( text1Length &lt; text2Length ) {
			text2 = text2.substring( 0, text1Length );
		}
		textLength = Math.min( text1Length, text2Length );

		// Quick check for the worst case.
		if ( text1 === text2 ) {
			return textLength;
		}

		// Start by looking for a single character match
		// and increase length until no match is found.
		// Performance analysis: https://neil.fraser.name/news/2010/11/04/
		best = 0;
		length = 1;
		while ( true ) {
			pattern = text1.substring( textLength - length );
			found = text2.indexOf( pattern );
			if ( found === -1 ) {
				return best;
			}
			length += found;
			if ( found === 0 || text1.substring( textLength - length ) ===
					text2.substring( 0, length ) ) {
				best = length;
				length++;
			}
		}
	};

	/**
	 * Split two texts into an array of strings.  Reduce the texts to a string of
	 * hashes where each Unicode character represents one line.
	 * @param {string} text1 First string.
	 * @param {string} text2 Second string.
	 * @return {{chars1: string, chars2: string, lineArray: !Array.&lt;string&gt;}}
	 *     An object containing the encoded text1, the encoded text2 and
	 *     the array of unique strings.
	 *     The zeroth element of the array of unique strings is intentionally blank.
	 * @private
	 */
	DiffMatchPatch.prototype.diffLinesToChars = function( text1, text2 ) {
		var lineArray, lineHash, chars1, chars2;
		lineArray = []; // E.g. lineArray[4] === &apos;Hello\n&apos;
		lineHash = {};  // E.g. lineHash[&apos;Hello\n&apos;] === 4

		// &apos;\x00&apos; is a valid character, but various debuggers don&apos;t like it.
		// So we&apos;ll insert a junk entry to avoid generating a null character.
		lineArray[ 0 ] = &quot;&quot;;

		/**
		 * Split a text into an array of strings.  Reduce the texts to a string of
		 * hashes where each Unicode character represents one line.
		 * Modifies linearray and linehash through being a closure.
		 * @param {string} text String to encode.
		 * @return {string} Encoded string.
		 * @private
		 */
		function diffLinesToCharsMunge( text ) {
			var chars, lineStart, lineEnd, lineArrayLength, line;
			chars = &quot;&quot;;

			// Walk the text, pulling out a substring for each line.
			// text.split(&apos;\n&apos;) would would temporarily double our memory footprint.
			// Modifying text would create many large strings to garbage collect.
			lineStart = 0;
			lineEnd = -1;

			// Keeping our own length variable is faster than looking it up.
			lineArrayLength = lineArray.length;
			while ( lineEnd &lt; text.length - 1 ) {
				lineEnd = text.indexOf( &quot;\n&quot;, lineStart );
				if ( lineEnd === -1 ) {
					lineEnd = text.length - 1;
				}
				line = text.substring( lineStart, lineEnd + 1 );
				lineStart = lineEnd + 1;

				if ( lineHash.hasOwnProperty ? lineHash.hasOwnProperty( line ) :
							( lineHash[ line ] !== undefined ) ) {
					chars += String.fromCharCode( lineHash[ line ] );
				} else {
					chars += String.fromCharCode( lineArrayLength );
					lineHash[ line ] = lineArrayLength;
					lineArray[ lineArrayLength++ ] = line;
				}
			}
			return chars;
		}

		chars1 = diffLinesToCharsMunge( text1 );
		chars2 = diffLinesToCharsMunge( text2 );
		return {
			chars1: chars1,
			chars2: chars2,
			lineArray: lineArray
		};
	};

	/**
	 * Rehydrate the text in a diff from a string of line hashes to real lines of
	 * text.
	 * @param {!Array.&lt;!DiffMatchPatch.Diff&gt;} diffs Array of diff tuples.
	 * @param {!Array.&lt;string&gt;} lineArray Array of unique strings.
	 * @private
	 */
	DiffMatchPatch.prototype.diffCharsToLines = function( diffs, lineArray ) {
		var x, chars, text, y;
		for ( x = 0; x &lt; diffs.length; x++ ) {
			chars = diffs[ x ][ 1 ];
			text = [];
			for ( y = 0; y &lt; chars.length; y++ ) {
				text[ y ] = lineArray[ chars.charCodeAt( y ) ];
			}
			diffs[ x ][ 1 ] = text.join( &quot;&quot; );
		}
	};

	/**
	 * Reorder and merge like edit sections.  Merge equalities.
	 * Any edit section can move as long as it doesn&apos;t cross an equality.
	 * @param {!Array.&lt;!DiffMatchPatch.Diff&gt;} diffs Array of diff tuples.
	 */
	DiffMatchPatch.prototype.diffCleanupMerge = function( diffs ) {
		var pointer, countDelete, countInsert, textInsert, textDelete,
			commonlength, changes, diffPointer, position;
		diffs.push( [ DIFF_EQUAL, &quot;&quot; ] ); // Add a dummy entry at the end.
		pointer = 0;
		countDelete = 0;
		countInsert = 0;
		textDelete = &quot;&quot;;
		textInsert = &quot;&quot;;
		commonlength;
		while ( pointer &lt; diffs.length ) {
			switch ( diffs[ pointer ][ 0 ] ) {
			case DIFF_INSERT:
				countInsert++;
				textInsert += diffs[ pointer ][ 1 ];
				pointer++;
				break;
			case DIFF_DELETE:
				countDelete++;
				textDelete += diffs[ pointer ][ 1 ];
				pointer++;
				break;
			case DIFF_EQUAL:

				// Upon reaching an equality, check for prior redundancies.
				if ( countDelete + countInsert &gt; 1 ) {
					if ( countDelete !== 0 &amp;&amp; countInsert !== 0 ) {

						// Factor out any common prefixes.
						commonlength = this.diffCommonPrefix( textInsert, textDelete );
						if ( commonlength !== 0 ) {
							if ( ( pointer - countDelete - countInsert ) &gt; 0 &amp;&amp;
									diffs[ pointer - countDelete - countInsert - 1 ][ 0 ] ===
									DIFF_EQUAL ) {
								diffs[ pointer - countDelete - countInsert - 1 ][ 1 ] +=
									textInsert.substring( 0, commonlength );
							} else {
								diffs.splice( 0, 0, [ DIFF_EQUAL,
									textInsert.substring( 0, commonlength )
								] );
								pointer++;
							}
							textInsert = textInsert.substring( commonlength );
							textDelete = textDelete.substring( commonlength );
						}

						// Factor out any common suffixies.
						commonlength = this.diffCommonSuffix( textInsert, textDelete );
						if ( commonlength !== 0 ) {
							diffs[ pointer ][ 1 ] = textInsert.substring( textInsert.length -
									commonlength ) + diffs[ pointer ][ 1 ];
							textInsert = textInsert.substring( 0, textInsert.length -
								commonlength );
							textDelete = textDelete.substring( 0, textDelete.length -
								commonlength );
						}
					}

					// Delete the offending records and add the merged ones.
					if ( countDelete === 0 ) {
						diffs.splice( pointer - countInsert,
							countDelete + countInsert, [ DIFF_INSERT, textInsert ] );
					} else if ( countInsert === 0 ) {
						diffs.splice( pointer - countDelete,
							countDelete + countInsert, [ DIFF_DELETE, textDelete ] );
					} else {
						diffs.splice(
							pointer - countDelete - countInsert,
							countDelete + countInsert,
							[ DIFF_DELETE, textDelete ], [ DIFF_INSERT, textInsert ]
						);
					}
					pointer = pointer - countDelete - countInsert +
						( countDelete ? 1 : 0 ) + ( countInsert ? 1 : 0 ) + 1;
				} else if ( pointer !== 0 &amp;&amp; diffs[ pointer - 1 ][ 0 ] === DIFF_EQUAL ) {

					// Merge this equality with the previous one.
					diffs[ pointer - 1 ][ 1 ] += diffs[ pointer ][ 1 ];
					diffs.splice( pointer, 1 );
				} else {
					pointer++;
				}
				countInsert = 0;
				countDelete = 0;
				textDelete = &quot;&quot;;
				textInsert = &quot;&quot;;
				break;
			}
		}
		if ( diffs[ diffs.length - 1 ][ 1 ] === &quot;&quot; ) {
			diffs.pop(); // Remove the dummy entry at the end.
		}

		// Second pass: look for single edits surrounded on both sides by equalities
		// which can be shifted sideways to eliminate an equality.
		// e.g: A&lt;ins&gt;BA&lt;/ins&gt;C -&gt; &lt;ins&gt;AB&lt;/ins&gt;AC
		changes = false;
		pointer = 1;

		// Intentionally ignore the first and last element (don&apos;t need checking).
		while ( pointer &lt; diffs.length - 1 ) {
			if ( diffs[ pointer - 1 ][ 0 ] === DIFF_EQUAL &amp;&amp;
					diffs[ pointer + 1 ][ 0 ] === DIFF_EQUAL ) {

				diffPointer = diffs[ pointer ][ 1 ];
				position = diffPointer.substring(
					diffPointer.length - diffs[ pointer - 1 ][ 1 ].length
				);

				// This is a single edit surrounded by equalities.
				if ( position === diffs[ pointer - 1 ][ 1 ] ) {

					// Shift the edit over the previous equality.
					diffs[ pointer ][ 1 ] = diffs[ pointer - 1 ][ 1 ] +
						diffs[ pointer ][ 1 ].substring( 0, diffs[ pointer ][ 1 ].length -
							diffs[ pointer - 1 ][ 1 ].length );
					diffs[ pointer + 1 ][ 1 ] =
						diffs[ pointer - 1 ][ 1 ] + diffs[ pointer + 1 ][ 1 ];
					diffs.splice( pointer - 1, 1 );
					changes = true;
				} else if ( diffPointer.substring( 0, diffs[ pointer + 1 ][ 1 ].length ) ===
						diffs[ pointer + 1 ][ 1 ] ) {

					// Shift the edit over the next equality.
					diffs[ pointer - 1 ][ 1 ] += diffs[ pointer + 1 ][ 1 ];
					diffs[ pointer ][ 1 ] =
						diffs[ pointer ][ 1 ].substring( diffs[ pointer + 1 ][ 1 ].length ) +
						diffs[ pointer + 1 ][ 1 ];
					diffs.splice( pointer + 1, 1 );
					changes = true;
				}
			}
			pointer++;
		}

		// If shifts were made, the diff needs reordering and another shift sweep.
		if ( changes ) {
			this.diffCleanupMerge( diffs );
		}
	};

	return function( o, n ) {
		var diff, output, text;
		diff = new DiffMatchPatch();
		output = diff.DiffMain( o, n );
		diff.diffCleanupEfficiency( output );
		text = diff.diffPrettyHtml( output );

		return text;
	};
}() );

}() );
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.5.2)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
